; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\uart.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\uart.d --feedback=.\obj\ak2_v1_1_0.fed --cpu=Cortex-M0 --apcs=interwork -O3 --diag_suppress=9931 -I..\Include -I..\user -I..\Include\app_common -I..\Include\ble -I..\Include\ble\ble_services -I..\Include\s110 -I..\Include\boards -I..\Include\sd_common -IC:\Johnson_project\2016_Project\BLE_Pedometer\Fittless_wearable\firmware_design\git-project\arm\RTE -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.6.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DNRF51 -DNRF51 -DDEBUG_NRF_USER -DSETUPA -DBOARD_AKII -DBLE_STACK_SUPPORT_REQD --omf_browse=.\obj\uart.crf ..\user\uart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  UART_Decode PROC
;;;191    ////////////////////////////////////////////////////////////////
;;;192    void UART_Decode(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;193    {	
;;;194      int i=0, j=0;
;;;195    	
;;;196     #if 	 BLE_UART & UART_TO_BLE
;;;197    	uint32_t err_code=0;
;;;198    	if((rx_flag>0) && (rx_flag<20))
;;;199    	{	
;;;200    		 
;;;201    	 err_code = ble_nus_send_string(&m_nus, Rx_Buff, rx_flag );      //上传数据
;;;202       if (err_code != NRF_ERROR_INVALID_STATE)
;;;203       {
;;;204       APP_ERROR_CHECK(err_code);
;;;205       }
;;;206     }
;;;207    	 
;;;208    	 #endif		
;;;209    	
;;;210    	
;;;211    	
;;;212    #ifndef  ENABLE_LOOPBACK_TEST
;;;213    		/*Get the input character*/
;;;214    #if (UART_Func_Int)		
;;;215    		
;;;216    		if(rx_flag)
000002  4dc1              LDR      r5,|L1.776|
000004  2400              MOVS     r4,#0                 ;194
000006  7828              LDRB     r0,[r5,#0]  ; rx_flag
000008  2800              CMP      r0,#0
00000a  d075              BEQ      |L1.248|
;;;217    		 {
;;;218    			 nrf_delay_ms(500); 
00000c  20ff              MOVS     r0,#0xff
00000e  30f5              ADDS     r0,r0,#0xf5
000010  f7fffffe          BL       nrf_delay_ms
;;;219    			for(i=0; i<rx_flag; i++)
;;;220           {		
;;;221    #if 0				 
;;;222          simple_uart_put(Rx_Buff[i]);
;;;223    
;;;224        if(Rx_Buff[i]== 'q' || Rx_Buff[i] == 'Q')
;;;225         {
;;;226    			 printf(" \n\rExit!\n\r");
;;;227    			  nrf_gpio_pin_toggle(LED4);
;;;228    			 break;
;;;229         } 	
;;;230    #endif		 
;;;231    
;;;232    
;;;233      	 switch(Rx_Buff[i])
000014  4ebd              LDR      r6,|L1.780|
000016  2700              MOVS     r7,#0
000018  e0cb              B        |L1.434|
                  |L1.26|
00001a  5d30              LDRB     r0,[r6,r4]
00001c  2873              CMP      r0,#0x73
                  |L1.30|
00001e  d129              BNE      |L1.116|
;;;234    				 {
;;;235    
;;;236    				 
;;;237    		case  's' :
;;;238    #if RTC_Func				
;;;239    			         if(Rx_Buff[i+1]=='c')
000020  1930              ADDS     r0,r6,r4
000022  4684              MOV      r12,r0
000024  7840              LDRB     r0,[r0,#1]
000026  4686              MOV      lr,r0
000028  2863              CMP      r0,#0x63
00002a  d17c              BNE      |L1.294|
00002c  4660              MOV      r0,r12
;;;240    		           {
;;;241    						     switch(Rx_Buff[i+2])
00002e  7880              LDRB     r0,[r0,#2]
000030  2868              CMP      r0,#0x68
000032  d036              BEQ      |L1.162|
000034  dc06              BGT      |L1.68|
000036  284d              CMP      r0,#0x4d
000038  d05f              BEQ      |L1.250|
00003a  2859              CMP      r0,#0x59
00003c  d075              BEQ      |L1.298|
00003e  2864              CMP      r0,#0x64
000040  d1ed              BNE      |L1.30|
000042  e044              B        |L1.206|
                  |L1.68|
000044  286d              CMP      r0,#0x6d
000046  d016              BEQ      |L1.118|
000048  2873              CMP      r0,#0x73
00004a  d1e8              BNE      |L1.30|
00004c  4660              MOV      r0,r12
;;;242                     {
;;;243                     case 's':   // set second
;;;244    									          if((Rx_Buff[i+3]>='0')&&(Rx_Buff[i+3]<='9'))
00004e  78c1              LDRB     r1,[r0,#3]
000050  3930              SUBS     r1,r1,#0x30
000052  2909              CMP      r1,#9
000054  d80e              BHI      |L1.116|
;;;245    														{
;;;246                                  if((Rx_Buff[i+4]>='0')&&(Rx_Buff[i+4]<='9'))
000056  7900              LDRB     r0,[r0,#4]
000058  4602              MOV      r2,r0
00005a  3a30              SUBS     r2,r2,#0x30
00005c  2a09              CMP      r2,#9
00005e  d809              BHI      |L1.116|
000060  4662              MOV      r2,r12
;;;247    															{
;;;248    																if(Rx_Buff[i+5]=='e')
000062  7952              LDRB     r2,[r2,#5]
000064  2a65              CMP      r2,#0x65
000066  d105              BNE      |L1.116|
;;;249    																{
;;;250    																RTC_Con.Second_Reg=((Rx_Buff[i+3]-0x30)*10) + Rx_Buff[i+4]-0x30 ;
000068  220a              MOVS     r2,#0xa
00006a  4351              MULS     r1,r2,r1
00006c  3930              SUBS     r1,r1,#0x30
00006e  1840              ADDS     r0,r0,r1
000070  49a7              LDR      r1,|L1.784|
000072  7048              STRB     r0,[r1,#1]
                  |L1.116|
000074  e09c              B        |L1.432|
                  |L1.118|
000076  4660              MOV      r0,r12
;;;251    																}	
;;;252    															}	
;;;253    														}															
;;;254                                 break;
;;;255    														
;;;256    								 case 'm':   // set mintue
;;;257    									          if((Rx_Buff[i+3]>='0')&&(Rx_Buff[i+3]<='9'))
000078  78c0              LDRB     r0,[r0,#3]
00007a  3830              SUBS     r0,r0,#0x30
00007c  2809              CMP      r0,#9
00007e  d80f              BHI      |L1.160|
000080  4661              MOV      r1,r12
;;;258    														{
;;;259                                  if((Rx_Buff[i+4]>='0')&&(Rx_Buff[i+4]<='9'))
000082  7909              LDRB     r1,[r1,#4]
000084  460a              MOV      r2,r1
000086  3a30              SUBS     r2,r2,#0x30
000088  2a09              CMP      r2,#9
00008a  d809              BHI      |L1.160|
00008c  4662              MOV      r2,r12
;;;260    															{
;;;261    																if(Rx_Buff[i+5]=='e')
00008e  7952              LDRB     r2,[r2,#5]
000090  2a65              CMP      r2,#0x65
000092  d105              BNE      |L1.160|
;;;262    																{
;;;263    																 RTC_Con.Min_Reg=((Rx_Buff[i+3]-0x30)*10) + Rx_Buff[i+4]-0x30 ;
000094  220a              MOVS     r2,#0xa
000096  4350              MULS     r0,r2,r0
000098  3830              SUBS     r0,r0,#0x30
00009a  1809              ADDS     r1,r1,r0
00009c  489c              LDR      r0,|L1.784|
00009e  7081              STRB     r1,[r0,#2]
                  |L1.160|
0000a0  e086              B        |L1.432|
                  |L1.162|
0000a2  4660              MOV      r0,r12
;;;264    																}	
;;;265    															}	
;;;266    														}															
;;;267                                 break;		
;;;268    
;;;269                        case 'h':   // set mintue
;;;270    									          if((Rx_Buff[i+3]>='0')&&(Rx_Buff[i+3]<='9'))
0000a4  78c0              LDRB     r0,[r0,#3]
0000a6  3830              SUBS     r0,r0,#0x30
0000a8  2809              CMP      r0,#9
0000aa  d80f              BHI      |L1.204|
0000ac  4661              MOV      r1,r12
;;;271    														{
;;;272                                  if((Rx_Buff[i+4]>='0')&&(Rx_Buff[i+4]<='9'))
0000ae  7909              LDRB     r1,[r1,#4]
0000b0  460a              MOV      r2,r1
0000b2  3a30              SUBS     r2,r2,#0x30
0000b4  2a09              CMP      r2,#9
0000b6  d87b              BHI      |L1.432|
0000b8  4662              MOV      r2,r12
;;;273    															{
;;;274    																if(Rx_Buff[i+5]=='e')
0000ba  7952              LDRB     r2,[r2,#5]
0000bc  2a65              CMP      r2,#0x65
0000be  d177              BNE      |L1.432|
;;;275    																{
;;;276    																 RTC_Con.Hour_Reg=((Rx_Buff[i+3]-0x30)*10) + Rx_Buff[i+4]-0x30 ;
0000c0  220a              MOVS     r2,#0xa
0000c2  4350              MULS     r0,r2,r0
0000c4  3830              SUBS     r0,r0,#0x30
0000c6  1808              ADDS     r0,r1,r0
0000c8  4991              LDR      r1,|L1.784|
0000ca  70c8              STRB     r0,[r1,#3]
                  |L1.204|
0000cc  e070              B        |L1.432|
                  |L1.206|
0000ce  4660              MOV      r0,r12
;;;277    																}	
;;;278    															}	
;;;279    														}															
;;;280                                 break;		
;;;281    
;;;282    
;;;283                       case 'd':   // set day
;;;284    									          if((Rx_Buff[i+3]>='0')&&(Rx_Buff[i+3]<='9'))
0000d0  78c1              LDRB     r1,[r0,#3]
0000d2  3930              SUBS     r1,r1,#0x30
0000d4  2909              CMP      r1,#9
0000d6  d86b              BHI      |L1.432|
;;;285    														{
;;;286                                  if((Rx_Buff[i+4]>='0')&&(Rx_Buff[i+4]<='9'))
0000d8  7900              LDRB     r0,[r0,#4]
0000da  4602              MOV      r2,r0
0000dc  3a30              SUBS     r2,r2,#0x30
0000de  2a09              CMP      r2,#9
0000e0  d866              BHI      |L1.432|
0000e2  4662              MOV      r2,r12
;;;287    															{
;;;288    																if(Rx_Buff[i+5]=='e')
0000e4  7952              LDRB     r2,[r2,#5]
0000e6  2a65              CMP      r2,#0x65
0000e8  d162              BNE      |L1.432|
;;;289    																{
;;;290    																 RTC_Con.Day_Reg=((Rx_Buff[i+3]-0x30)*10) + Rx_Buff[i+4]-0x30 ;
0000ea  220a              MOVS     r2,#0xa
0000ec  4351              MULS     r1,r2,r1
0000ee  3930              SUBS     r1,r1,#0x30
0000f0  1840              ADDS     r0,r0,r1
0000f2  4987              LDR      r1,|L1.784|
0000f4  7108              STRB     r0,[r1,#4]
0000f6  e05b              B        |L1.432|
                  |L1.248|
0000f8  e060              B        |L1.444|
                  |L1.250|
0000fa  4660              MOV      r0,r12
;;;291    																}	
;;;292    															}	
;;;293    														}															
;;;294                                 break;		
;;;295    
;;;296    
;;;297                       
;;;298                    case 'M':   // set Month
;;;299    									          if((Rx_Buff[i+3]>='0')&&(Rx_Buff[i+3]<='9'))
0000fc  78c0              LDRB     r0,[r0,#3]
0000fe  3830              SUBS     r0,r0,#0x30
000100  2809              CMP      r0,#9
000102  d855              BHI      |L1.432|
000104  4661              MOV      r1,r12
;;;300    														{
;;;301                                  if((Rx_Buff[i+4]>='0')&&(Rx_Buff[i+4]<='9'))
000106  7909              LDRB     r1,[r1,#4]
000108  460a              MOV      r2,r1
00010a  3a30              SUBS     r2,r2,#0x30
00010c  2a09              CMP      r2,#9
00010e  d84f              BHI      |L1.432|
000110  4662              MOV      r2,r12
;;;302    															{
;;;303    																if(Rx_Buff[i+5]=='e')
000112  7952              LDRB     r2,[r2,#5]
000114  2a65              CMP      r2,#0x65
000116  d14b              BNE      |L1.432|
;;;304    																{
;;;305    																 RTC_Con.Month_Reg=((Rx_Buff[i+3]-0x30)*10) + Rx_Buff[i+4]-0x30 ;
000118  220a              MOVS     r2,#0xa
00011a  4350              MULS     r0,r2,r0
00011c  3830              SUBS     r0,r0,#0x30
00011e  1808              ADDS     r0,r1,r0
000120  497b              LDR      r1,|L1.784|
000122  7148              STRB     r0,[r1,#5]
000124  e044              B        |L1.432|
                  |L1.294|
000126  e01e              B        |L1.358|
000128  e7ff              B        |L1.298|
                  |L1.298|
;;;306    																}	
;;;307    															}	
;;;308    														}															
;;;309                                 break;				
;;;310    
;;;311                    case 'Y':   // set year
;;;312    									          for(j=0; j<4; j++)
00012a  2000              MOVS     r0,#0
                  |L1.300|
00012c  1c40              ADDS     r0,r0,#1
00012e  2804              CMP      r0,#4
;;;313    								            {
;;;314    														if((Rx_Buff[i+3+j]<'0')&&(Rx_Buff[i+3+j]>'9'))
000130  dbfc              BLT      |L1.300|
000132  4660              MOV      r0,r12
;;;315    														 {
;;;316    															break;
;;;317    														 }
;;;318    														 														 
;;;319    															
;;;320    														}	
;;;321    									          if(Rx_Buff[i+7]=='e')
000134  79c0              LDRB     r0,[r0,#7]
000136  2865              CMP      r0,#0x65
000138  d115              BNE      |L1.358|
00013a  4660              MOV      r0,r12
;;;322    																{
;;;323    																 RTC_Con.Year_Reg=((Rx_Buff[i+3]-0x30)*1000) + ((Rx_Buff[i+4]-0x30)*100)+ 
00013c  7981              LDRB     r1,[r0,#6]
00013e  78c0              LDRB     r0,[r0,#3]
000140  227d              MOVS     r2,#0x7d
000142  00d2              LSLS     r2,r2,#3
000144  3830              SUBS     r0,r0,#0x30
000146  4350              MULS     r0,r2,r0
000148  180a              ADDS     r2,r1,r0
00014a  4660              MOV      r0,r12
00014c  7900              LDRB     r0,[r0,#4]
00014e  2164              MOVS     r1,#0x64
000150  4348              MULS     r0,r1,r0
000152  4661              MOV      r1,r12
000154  7949              LDRB     r1,[r1,#5]
000156  230a              MOVS     r3,#0xa
000158  4359              MULS     r1,r3,r1
00015a  1840              ADDS     r0,r0,r1
00015c  496d              LDR      r1,|L1.788|
00015e  1810              ADDS     r0,r2,r0
000160  1840              ADDS     r0,r0,r1
000162  496b              LDR      r1,|L1.784|
000164  80c8              STRH     r0,[r1,#6]
                  |L1.358|
000166  4670              MOV      r0,lr
;;;324    																	  ((Rx_Buff[i+5]-0x30)*10)+((Rx_Buff[i+6]-0x30));
;;;325    																}	
;;;326                             
;;;327    																												
;;;328                                 break;																
;;;329    
;;;330    														
;;;331    
;;;332    
;;;333    								 }									 
;;;334    								 
;;;335    								 
;;;336    							 } 
;;;337    #endif  // end of RTC setting 
;;;338    
;;;339     #if OLED096_Func             
;;;340     if(Rx_Buff[i+1]=='o')
000168  286f              CMP      r0,#0x6f
00016a  d121              BNE      |L1.432|
00016c  4660              MOV      r0,r12
;;;341    		           {
;;;342    						     switch(Rx_Buff[i+2])
00016e  7880              LDRB     r0,[r0,#2]
000170  2864              CMP      r0,#0x64
000172  d019              BEQ      |L1.424|
000174  2869              CMP      r0,#0x69
000176  d11b              BNE      |L1.432|
000178  4660              MOV      r0,r12
;;;343                     {
;;;344                     case 'i':   // increase OLED contrast
;;;345    									            if(Rx_Buff[i+3]!='e')
00017a  78c0              LDRB     r0,[r0,#3]
00017c  2865              CMP      r0,#0x65
00017e  d117              BNE      |L1.432|
;;;346    															{
;;;347    																break;
;;;348    															}	
;;;349    									           if(OLED_Contrast<0xDF)
000180  4865              LDR      r0,|L1.792|
000182  7801              LDRB     r1,[r0,#0]  ; OLED_Contrast
000184  29df              CMP      r1,#0xdf
000186  d202              BCS      |L1.398|
;;;350    														 {	 
;;;351    															OLED_Contrast+=0x20; 
000188  7801              LDRB     r1,[r0,#0]  ; OLED_Contrast
00018a  3120              ADDS     r1,r1,#0x20
;;;352    									           OLED_WR_Byte(0x81,OLED_CMD); //对比度设置	
;;;353    														 OLED_WR_Byte(OLED_Contrast,OLED_CMD); 
00018c  e001              B        |L1.402|
                  |L1.398|
;;;354    														 } 	
;;;355    														 else
;;;356    														 {
;;;357    														 OLED_Contrast =0xff; 
00018e  4862              LDR      r0,|L1.792|
000190  21ff              MOVS     r1,#0xff
                  |L1.402|
000192  7001              STRB     r1,[r0,#0]
                  |L1.404|
;;;358    									           OLED_WR_Byte(0x81,OLED_CMD); //对比度设置	
000194  2100              MOVS     r1,#0
000196  2081              MOVS     r0,#0x81
000198  f7fffffe          BL       OLED_WR_Byte
;;;359    														 OLED_WR_Byte(OLED_Contrast,OLED_CMD);  
00019c  485e              LDR      r0,|L1.792|
00019e  2100              MOVS     r1,#0
0001a0  7800              LDRB     r0,[r0,#0]  ; OLED_Contrast
0001a2  f7fffffe          BL       OLED_WR_Byte
0001a6  e003              B        |L1.432|
                  |L1.424|
0001a8  4660              MOV      r0,r12
;;;360    															 
;;;361    														 } 
;;;362    															 
;;;363    															 
;;;364                                 break;
;;;365    														
;;;366    								 case 'd':   // decrease OLED contrast
;;;367    									             if(Rx_Buff[i+3]!='e')
0001aa  78c0              LDRB     r0,[r0,#3]
0001ac  2865              CMP      r0,#0x65
0001ae  d006              BEQ      |L1.446|
                  |L1.432|
0001b0  1c64              ADDS     r4,r4,#1
                  |L1.434|
0001b2  7828              LDRB     r0,[r5,#0]            ;219  ; rx_flag
0001b4  4284              CMP      r4,r0                 ;219
0001b6  da00              BGE      |L1.442|
0001b8  e72f              B        |L1.26|
                  |L1.442|
;;;368    															{
;;;369    																break;
;;;370    															}	
;;;371    									         if(OLED_Contrast>=0x20)
;;;372    														 {	 
;;;373    															OLED_Contrast-=0x20; 
;;;374    									           OLED_WR_Byte(0x81,OLED_CMD); //对比度设置	
;;;375    														 OLED_WR_Byte(OLED_Contrast,OLED_CMD); 
;;;376    														 } 
;;;377    														 else
;;;378    														 {
;;;379    														 OLED_Contrast =0x00; 
;;;380    									           OLED_WR_Byte(0x81,OLED_CMD); //对比度设置	
;;;381    														 OLED_WR_Byte(OLED_Contrast,OLED_CMD); 
;;;382    
;;;383    														 }															 
;;;384                                 break;		
;;;385    
;;;386    														
;;;387    
;;;388    
;;;389    								 }									 
;;;390    								 
;;;391    							 } 
;;;392    #endif			// 				 
;;;393    			          break; 
;;;394    
;;;395    		 
;;;396    	       }
;;;397    			 } 
;;;398          rx_flag=0;
0001ba  702f              STRB     r7,[r5,#0]
                  |L1.444|
;;;399    		 }			 
;;;400    #else		
;;;401        cr = simple_uart_get(); 
;;;402        simple_uart_put(cr);
;;;403    
;;;404        if(cr == 'q' || cr == 'Q')
;;;405        {
;;;406          uart_quit();
;;;407          while(1){}
;;;408        }		
;;;409    
;;;410    #endif //  end of non-interrupt function		
;;;411    		
;;;412    #else		
;;;413    		  uart_loopback_test();
;;;414    
;;;415    #endif   // end of loop back function
;;;416    
;;;417    
;;;418    
;;;419    
;;;420    
;;;421    
;;;422    
;;;423    
;;;424    }
0001bc  bdf8              POP      {r3-r7,pc}
                  |L1.446|
0001be  4856              LDR      r0,|L1.792|
0001c0  7801              LDRB     r1,[r0,#0]            ;371  ; OLED_Contrast
0001c2  2920              CMP      r1,#0x20              ;371
0001c4  d304              BCC      |L1.464|
0001c6  7800              LDRB     r0,[r0,#0]            ;373  ; OLED_Contrast
0001c8  4953              LDR      r1,|L1.792|
0001ca  3820              SUBS     r0,r0,#0x20           ;373
0001cc  7008              STRB     r0,[r1,#0]            ;373
0001ce  e7e1              B        |L1.404|
                  |L1.464|
0001d0  7007              STRB     r7,[r0,#0]            ;379
0001d2  e7df              B        |L1.404|
;;;425    
                          ENDP

                  UART0_IRQHandler PROC
;;;131    */
;;;132    void UART0_IRQHandler(void)
0001d4  b570              PUSH     {r4-r6,lr}
;;;133    {
;;;134    	//uint8_t cr=0;
;;;135    // Handle reception
;;;136    if (NRF_UART0->EVENTS_RXDRDY != 0)
0001d6  4851              LDR      r0,|L1.796|
0001d8  6881              LDR      r1,[r0,#8]
0001da  2900              CMP      r1,#0
0001dc  d00f              BEQ      |L1.510|
;;;137    {
;;;138    // Clear UART RX event flag
;;;139    NRF_UART0->EVENTS_RXDRDY = 0;
0001de  2100              MOVS     r1,#0
0001e0  6081              STR      r1,[r0,#8]
;;;140    //cr = (uint8_t)NRF_UART0->RXD;
;;;141    if(rx_flag<64)
0001e2  4c49              LDR      r4,|L1.776|
0001e4  7820              LDRB     r0,[r4,#0]  ; rx_flag
;;;142    {	
;;;143     Rx_Buff[rx_flag++]=(uint8_t)NRF_UART0->RXD;
0001e6  4e4e              LDR      r6,|L1.800|
0001e8  4d48              LDR      r5,|L1.780|
0001ea  2840              CMP      r0,#0x40              ;141
0001ec  d301              BCC      |L1.498|
;;;144    }
;;;145    else
;;;146    {
;;;147    	UART_Decode();
0001ee  f7fffffe          BL       UART_Decode
                  |L1.498|
0001f2  69b1              LDR      r1,[r6,#0x18]         ;143
0001f4  7820              LDRB     r0,[r4,#0]            ;143  ; rx_flag
0001f6  182a              ADDS     r2,r5,r0              ;143
0001f8  1c40              ADDS     r0,r0,#1              ;143
0001fa  7020              STRB     r0,[r4,#0]            ;143
0001fc  7011              STRB     r1,[r2,#0]            ;143
                  |L1.510|
;;;148    	 Rx_Buff[rx_flag++]=(uint8_t)NRF_UART0->RXD;
;;;149    }
;;;150      }
;;;151    }
0001fe  bd70              POP      {r4-r6,pc}
;;;152    
                          ENDP

                  UART_init PROC
;;;159    
;;;160    void UART_init(void)
000200  b508              PUSH     {r3,lr}
;;;161    {	
;;;162    simple_uart_config(RTS_PIN_NUMBER, TX_PIN_NUMBER, CTS_PIN_NUMBER, RX_PIN_NUMBER, HWFC);
000202  2000              MOVS     r0,#0
000204  9000              STR      r0,[sp,#0]
000206  230b              MOVS     r3,#0xb
000208  220a              MOVS     r2,#0xa
00020a  2109              MOVS     r1,#9
00020c  2008              MOVS     r0,#8
00020e  f7fffffe          BL       simple_uart_config
;;;163    #if 	UART_Func_Int
;;;164    // Enable UART interrupt
;;;165    NRF_UART0->INTENCLR = 0xffffffffUL;
000212  2000              MOVS     r0,#0
000214  4943              LDR      r1,|L1.804|
000216  43c0              MVNS     r0,r0
000218  6088              STR      r0,[r1,#8]
;;;166    NRF_UART0->INTENSET = (UART_INTENSET_RXDRDY_Set << UART_INTENSET_RXDRDY_Pos);
00021a  2004              MOVS     r0,#4
00021c  6048              STR      r0,[r1,#4]
00021e  4942              LDR      r1,|L1.808|
000220  6008              STR      r0,[r1,#0]
000222  4a42              LDR      r2,|L1.812|
000224  6811              LDR      r1,[r2,#0]
000226  23ff              MOVS     r3,#0xff
000228  041b              LSLS     r3,r3,#16
00022a  4399              BICS     r1,r1,r3
00022c  6011              STR      r1,[r2,#0]
00022e  4940              LDR      r1,|L1.816|
000230  6008              STR      r0,[r1,#0]
;;;167    	// |(UART_INTENSET_TXDRDY_Set << UART_INTENSET_TXDRDY_Pos) |
;;;168     //(UART_INTENSET_ERROR_Set << UART_INTENSET_ERROR_Pos);
;;;169    NVIC_ClearPendingIRQ(UART0_IRQn);
;;;170    NVIC_SetPriority(UART0_IRQn, 0);
;;;171    NVIC_EnableIRQ(UART0_IRQn);   // enable interrupt
;;;172    #endif	
;;;173    
;;;174    #ifndef ENABLE_LOOPBACK_TEST	
;;;175    // uart_start(); // send start debug message
;;;176     printf("\n\rStart: ");
000232  a040              ADR      r0,|L1.820|
000234  f7fffffe          BL       __2printf
;;;177     printf("\n\rFriwmare Version: ");
000238  a041              ADR      r0,|L1.832|
00023a  f7fffffe          BL       __2printf
;;;178    //simple_uart_putstring((const uint8_t *)"\n\rFriwmare Version: ");
;;;179    // simple_uart_putstring((const uint8_t *)  Firmware_Ver);
;;;180     printf("%s",Firmware_Ver);
00023e  4946              LDR      r1,|L1.856|
000240  a046              ADR      r0,|L1.860|
000242  f7fffffe          BL       __2printf
;;;181    
;;;182    #else
;;;183    	// ERROR_PIN configure as output
;;;184      nrf_gpio_cfg_output(ERROR_PIN);
;;;185    #endif
;;;186    
;;;187    
;;;188    }
000246  bd08              POP      {r3,pc}
;;;189    
                          ENDP

                  Convert_8bit_to_BCD_ASCII PROC
;;;427    ///////////////////////////////////////////////////////
;;;428    void Convert_8bit_to_BCD_ASCII (unsigned char *buffer, unsigned char Data)
000248  b5f8              PUSH     {r3-r7,lr}
;;;429    {
00024a  4606              MOV      r6,r0
;;;430     unsigned char i=0;
;;;431      unsigned char temp=0;
;;;432     unsigned char result[3];
;;;433       temp= Data;
00024c  4608              MOV      r0,r1
00024e  2400              MOVS     r4,#0                 ;430
;;;434           result[0] = (temp/100 )+0x30;
000250  2164              MOVS     r1,#0x64
000252  f7fffffe          BL       __aeabi_uidivmod
000256  4602              MOV      r2,r0
000258  460d              MOV      r5,r1
00025a  3230              ADDS     r2,r2,#0x30
00025c  4668              MOV      r0,sp
00025e  7002              STRB     r2,[r0,#0]
;;;435    	   result[1] =  ((temp%100)/10)+0x30;
000260  4628              MOV      r0,r5
000262  210a              MOVS     r1,#0xa
000264  f7fffffe          BL       __aeabi_uidivmod
000268  4601              MOV      r1,r0
00026a  3130              ADDS     r1,r1,#0x30
00026c  4668              MOV      r0,sp
00026e  7041              STRB     r1,[r0,#1]
;;;436    	   result[2] = 	((temp%100)%10)+0x30;
000270  4628              MOV      r0,r5
000272  210a              MOVS     r1,#0xa
000274  f7fffffe          BL       __aeabi_uidivmod
000278  4668              MOV      r0,sp
00027a  3130              ADDS     r1,r1,#0x30
00027c  7081              STRB     r1,[r0,#2]
                  |L1.638|
;;;437    	    
;;;438    	   for(i=0; i<3; i++)
;;;439           {
;;;440    		    *buffer   =result[i];
00027e  5d01              LDRB     r1,[r0,r4]
000280  7031              STRB     r1,[r6,#0]
000282  1c64              ADDS     r4,r4,#1
000284  b2e4              UXTB     r4,r4                 ;438
000286  1c76              ADDS     r6,r6,#1              ;438
000288  2c03              CMP      r4,#3                 ;438
00028a  d3f8              BCC      |L1.638|
;;;441    			buffer++; 					
;;;442    		}
;;;443     }
00028c  bdf8              POP      {r3-r7,pc}
;;;444    
                          ENDP

                  Convert_16bit_to_BCD_ASCII PROC
;;;445    
;;;446    void Convert_16bit_to_BCD_ASCII (unsigned char *buffer, unsigned short Data)
00028e  b5fe              PUSH     {r1-r7,lr}
;;;447    {
;;;448     unsigned char i=0 ;
;;;449     unsigned short temp=0;
;;;450     unsigned char result[5];
;;;451       temp= Data;
000290  460e              MOV      r6,r1
000292  4605              MOV      r5,r0                 ;447
000294  2400              MOVS     r4,#0                 ;448
;;;452        
;;;453    	   result[0] = (temp/10000 )+0x30;		  // 10throusd
000296  4932              LDR      r1,|L1.864|
000298  4630              MOV      r0,r6
00029a  f7fffffe          BL       __aeabi_uidivmod
00029e  4602              MOV      r2,r0
0002a0  3230              ADDS     r2,r2,#0x30
0002a2  4668              MOV      r0,sp
0002a4  7002              STRB     r2,[r0,#0]
;;;454    	   result[1] =  ((temp%10000)/1000)+0x30;	  //1 thruosed
0002a6  277d              MOVS     r7,#0x7d
0002a8  4608              MOV      r0,r1
0002aa  00ff              LSLS     r7,r7,#3
0002ac  4639              MOV      r1,r7
0002ae  f7fffffe          BL       __aeabi_uidivmod
0002b2  4601              MOV      r1,r0
0002b4  3130              ADDS     r1,r1,#0x30
0002b6  4668              MOV      r0,sp
0002b8  7041              STRB     r1,[r0,#1]
;;;455    	   result[2] = 	((temp%1000)/100)+0x30;	  	  // 100
0002ba  4639              MOV      r1,r7
0002bc  4630              MOV      r0,r6
0002be  f7fffffe          BL       __aeabi_uidivmod
0002c2  4608              MOV      r0,r1
0002c4  2164              MOVS     r1,#0x64
0002c6  f7fffffe          BL       __aeabi_uidivmod
0002ca  4601              MOV      r1,r0
0002cc  3130              ADDS     r1,r1,#0x30
0002ce  4668              MOV      r0,sp
0002d0  7081              STRB     r1,[r0,#2]
;;;456    	   result[3] = 	((temp%100)/10)+0x30;		 // 10
0002d2  2164              MOVS     r1,#0x64
0002d4  4630              MOV      r0,r6
0002d6  f7fffffe          BL       __aeabi_uidivmod
0002da  4608              MOV      r0,r1
0002dc  210a              MOVS     r1,#0xa
0002de  f7fffffe          BL       __aeabi_uidivmod
0002e2  4601              MOV      r1,r0
0002e4  3130              ADDS     r1,r1,#0x30
0002e6  4668              MOV      r0,sp
0002e8  70c1              STRB     r1,[r0,#3]
;;;457    	   result[4] =   (temp%10)+0x30;			 // 1
0002ea  210a              MOVS     r1,#0xa
0002ec  4630              MOV      r0,r6
0002ee  f7fffffe          BL       __aeabi_uidivmod
0002f2  4668              MOV      r0,sp
0002f4  3130              ADDS     r1,r1,#0x30
0002f6  7101              STRB     r1,[r0,#4]
                  |L1.760|
;;;458    
;;;459           	    
;;;460    	   for(i=0; i<5; i++)
;;;461           {
;;;462    		    *buffer   =result[i];
0002f8  5d01              LDRB     r1,[r0,r4]
0002fa  7029              STRB     r1,[r5,#0]
0002fc  1c64              ADDS     r4,r4,#1
0002fe  b2e4              UXTB     r4,r4                 ;460
000300  1c6d              ADDS     r5,r5,#1              ;460
000302  2c05              CMP      r4,#5                 ;460
000304  d3f8              BCC      |L1.760|
;;;463    			buffer++; 					
;;;464    		}
;;;465    
;;;466    
;;;467    
;;;468     }
000306  bdfe              POP      {r1-r7,pc}
;;;469    
                          ENDP

                  |L1.776|
                          DCD      ||area_number.7||
                  |L1.780|
                          DCD      ||.bss||
                  |L1.784|
                          DCD      RTC_Con
                  |L1.788|
                          DCD      0xffffeb30
                  |L1.792|
                          DCD      OLED_Contrast
                  |L1.796|
                          DCD      0x40002100
                  |L1.800|
                          DCD      0x40002500
                  |L1.804|
                          DCD      0x40002300
                  |L1.808|
                          DCD      0xe000e280
                  |L1.812|
                          DCD      0xe000e400
                  |L1.816|
                          DCD      0xe000e100
                  |L1.820|
000334  0a0d5374          DCB      "\n\rStart: ",0
000338  6172743a
00033c  2000    
00033e  00                DCB      0
00033f  00                DCB      0
                  |L1.832|
000340  0a0d4672          DCB      "\n\rFriwmare Version: ",0
000344  69776d61
000348  72652056
00034c  65727369
000350  6f6e3a20
000354  00      
000355  00                DCB      0
000356  00                DCB      0
000357  00                DCB      0
                  |L1.856|
                          DCD      Firmware_Ver
                  |L1.860|
00035c  257300            DCB      "%s",0
00035f  00                DCB      0
                  |L1.864|
                          DCD      0x00002710

                          AREA ||area_number.2||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.2||, ||.text||
                  Convert_32bit_to_Hex_ASCII PROC
;;;473     
;;;474     void Convert_32bit_to_Hex_ASCII (unsigned char *buffer, unsigned int Data)
000000  b51c              PUSH     {r2-r4,lr}
;;;475     {
;;;476       unsigned char i=0;
000002  2200              MOVS     r2,#0
;;;477       unsigned int temp =0;
;;;478       unsigned char  result[8];
;;;479       temp= Data;
;;;480    // convert 32 MSB (28-32bit)
;;;481          	   if(((temp & 0xf0000000)>>28)<0x0a) 
000004  0f0b              LSRS     r3,r1,#28
000006  2b0a              CMP      r3,#0xa
;;;482    		     {
;;;483    		     result[0] =(unsigned char)(((temp &  0xf0000000)>>28)+0x30);
;;;484    
;;;485    			}
;;;486    		   else
;;;487    		     {
;;;488    
;;;489    			  result[0] = (unsigned char)(((temp &  0xf0000000)>>28)+0x37);
000008  466c              MOV      r4,sp
00000a  d201              BCS      |L2.16|
00000c  3330              ADDS     r3,r3,#0x30           ;475
00000e  e000              B        |L2.18|
                  |L2.16|
000010  3337              ADDS     r3,r3,#0x37           ;483
                  |L2.18|
000012  7023              STRB     r3,[r4,#0]
000014  010b              LSLS     r3,r1,#4
;;;490    			  }
;;;491    
;;;492    // convert 32 MSB (24-27bit)			 
;;;493    		     if(((temp & 0x0f000000)>>24)<0x0a) 
000016  0f1b              LSRS     r3,r3,#28
000018  2b0a              CMP      r3,#0xa
00001a  d201              BCS      |L2.32|
00001c  3330              ADDS     r3,r3,#0x30
;;;494    		     {
;;;495    		     result[1] = (unsigned char)(((temp & 0x0f000000)>>24)+0x30);
00001e  e000              B        |L2.34|
                  |L2.32|
000020  3337              ADDS     r3,r3,#0x37
                  |L2.34|
;;;496    
;;;497    			}
;;;498    		   else
;;;499    		     {
;;;500    
;;;501    			  result[1] = (unsigned char)(((temp & 0x0f000000)>>24)+0x37);
000022  7063              STRB     r3,[r4,#1]
;;;502    			  }
;;;503    // convert 32 MSB (20-23bit)	      
;;;504    		    if(((temp & 0x00f00000)>>20)<0x0a) 
000024  020b              LSLS     r3,r1,#8
000026  0f1b              LSRS     r3,r3,#28
000028  2b0a              CMP      r3,#0xa
00002a  d201              BCS      |L2.48|
00002c  3330              ADDS     r3,r3,#0x30
;;;505    		     {
;;;506    		     result[2] = ((temp & 0x00f00000)>>20)+0x30;
00002e  e000              B        |L2.50|
                  |L2.48|
000030  3337              ADDS     r3,r3,#0x37
                  |L2.50|
;;;507    
;;;508    			}
;;;509    		   else
;;;510    		     {
;;;511    
;;;512    			  result[2] = ((temp & 0x00f00000)>>20)+0x37;
000032  70a3              STRB     r3,[r4,#2]
;;;513    			  }
;;;514    // convert 32 MSB (16-19bit)	      
;;;515    		    if(((temp & 0x000f0000)>>16)<0x0a) 
000034  030b              LSLS     r3,r1,#12
000036  0f1b              LSRS     r3,r3,#28
000038  2b0a              CMP      r3,#0xa
00003a  d201              BCS      |L2.64|
00003c  3330              ADDS     r3,r3,#0x30
;;;516    		     {
;;;517    		     result[3] = ((temp & 0x000f0000)>>16)+0x30;
00003e  e000              B        |L2.66|
                  |L2.64|
000040  3337              ADDS     r3,r3,#0x37
                  |L2.66|
;;;518    
;;;519    			}
;;;520    		   else
;;;521    		     {
;;;522    
;;;523    			  result[3] = ((temp & 0x000f0000)>>16)+0x37;
000042  70e3              STRB     r3,[r4,#3]
;;;524    			  }
;;;525    // convert 32 MSB (12-15bit)	      
;;;526    		    if(((temp & 0x0000f000)>>12)<0x0a) 
000044  040b              LSLS     r3,r1,#16
000046  0f1b              LSRS     r3,r3,#28
000048  2b0a              CMP      r3,#0xa
00004a  d201              BCS      |L2.80|
00004c  3330              ADDS     r3,r3,#0x30
;;;527    		     {
;;;528    		     result[4] = ((temp & 0x0000f000)>>12)+0x30;
00004e  e000              B        |L2.82|
                  |L2.80|
000050  3337              ADDS     r3,r3,#0x37
                  |L2.82|
;;;529    
;;;530    			}
;;;531    		   else
;;;532    		     {
;;;533    
;;;534    			  result[4] = ((temp & 0x0000f000)>>12)+0x37;
000052  7123              STRB     r3,[r4,#4]
;;;535    			  }
;;;536    
;;;537    // convert 32 MSB (8-13bit)	      
;;;538    		    if(((temp & 0x00000f00)>>8)<0x0a) 
000054  050b              LSLS     r3,r1,#20
000056  0f1b              LSRS     r3,r3,#28
000058  2b0a              CMP      r3,#0xa
00005a  d201              BCS      |L2.96|
00005c  3330              ADDS     r3,r3,#0x30
;;;539    		     {
;;;540    		     result[5] = ((temp & 0x00000f00)>>8)+0x30;
00005e  e000              B        |L2.98|
                  |L2.96|
000060  3337              ADDS     r3,r3,#0x37
                  |L2.98|
;;;541    
;;;542    			}
;;;543    		   else
;;;544    		     {
;;;545    
;;;546    			  result[5] = ((temp & 0x00000f00)>>8)+0x37;
000062  7163              STRB     r3,[r4,#5]
;;;547    			  }
;;;548    // convert 32 MSB (4-7bit)	      
;;;549    		    if(((temp & 0x000000f0)>>4)<0x0a) 
000064  060b              LSLS     r3,r1,#24
000066  0f1b              LSRS     r3,r3,#28
000068  2b0a              CMP      r3,#0xa
00006a  d201              BCS      |L2.112|
00006c  3330              ADDS     r3,r3,#0x30
;;;550    		     {
;;;551    		     result[6] = ((temp & 0x000000f0)>>4)+0x30;
00006e  e000              B        |L2.114|
                  |L2.112|
000070  3337              ADDS     r3,r3,#0x37
                  |L2.114|
;;;552    
;;;553    			}
;;;554    		   else
;;;555    		     {
;;;556    
;;;557    			  result[6] = ((temp & 0x000000f0)>>4)+0x37;
;;;558    			  }
;;;559    // convert 32 MSB (0-3bit)	      
;;;560    		    if((temp & 0x0000000f)<0x0a) 
000072  0709              LSLS     r1,r1,#28
000074  71a3              STRB     r3,[r4,#6]            ;557
000076  0f09              LSRS     r1,r1,#28
000078  290a              CMP      r1,#0xa
;;;561    		     {
;;;562    		     result[7] = (temp & 0x0000000f)+0x30;
;;;563    
;;;564    			}
;;;565    		   else
;;;566    		     {
;;;567    
;;;568    			  result[7] = (temp & 0x0000000f)+0x37;
00007a  4623              MOV      r3,r4
00007c  d201              BCS      |L2.130|
00007e  3130              ADDS     r1,r1,#0x30
000080  e000              B        |L2.132|
                  |L2.130|
000082  3137              ADDS     r1,r1,#0x37           ;562
                  |L2.132|
000084  71d9              STRB     r1,[r3,#7]
000086  4619              MOV      r1,r3                 ;478
                  |L2.136|
;;;569    			 
;;;570    			  }
;;;571    // write 
;;;572    	     for(i=0; i<8; i++)
;;;573           {
;;;574    		    *buffer   =result[i];
000088  5c8b              LDRB     r3,[r1,r2]
00008a  7003              STRB     r3,[r0,#0]
00008c  1c52              ADDS     r2,r2,#1
00008e  b2d2              UXTB     r2,r2                 ;572
000090  1c40              ADDS     r0,r0,#1              ;572
000092  2a08              CMP      r2,#8                 ;572
000094  d3f8              BCC      |L2.136|
;;;575    			buffer++; 					
;;;576    		}
;;;577    
;;;578    
;;;579    
;;;580    
;;;581      }
000096  bd1c              POP      {r2-r4,pc}
;;;582    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  Rx_Buff
                          %        64

                          AREA ||.data||, DATA, ALIGN=0

                  ||cr||
000000  00                DCB      0x00

                          AREA ||area_number.7||, DATA, ALIGN=0

                          EXPORTAS ||area_number.7||, ||.data||
                  rx_flag
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\user\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_cr____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_uart_c_cr____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_cr____REVSH|
#line 144
|__asm___6_uart_c_cr____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_cr__nrf_delay_us|
#line 8 "..\\Include\\nrf_delay.h"
|__asm___6_uart_c_cr__nrf_delay_us| PROC
#line 9

loop
 SUBS R0, R0, #1
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 BNE loop
 BX LR
	ENDP

;*** End   embedded assembler ***
