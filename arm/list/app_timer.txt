; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\app_timer.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\app_timer.d --feedback=.\obj\ak2_v1_1_0.fed --cpu=Cortex-M0 --apcs=interwork -O3 --diag_suppress=9931 -I..\Include -I..\user -I..\Include\app_common -I..\Include\ble -I..\Include\ble\ble_services -I..\Include\s110 -I..\Include\boards -I..\Include\sd_common -IC:\Johnson_project\2016_Project\BLE_Pedometer\Fittless_wearable\firmware_design\git-project\arm\RTE -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.6.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DNRF51 -DNRF51 -DDEBUG_NRF_USER -DSETUPA -DBOARD_AKII -DBLE_STACK_SUPPORT_REQD --omf_browse=.\obj\app_timer.crf ..\Source\app_common\app_timer.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  NVIC_SetPriority PROC
;;;581     */
;;;582    __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  0783              LSLS     r3,r0,#30
;;;583    {
;;;584      if(IRQn < 0) {
;;;585        SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
000002  22ff              MOVS     r2,#0xff
000004  0edb              LSRS     r3,r3,#27
000006  409a              LSLS     r2,r2,r3
000008  0789              LSLS     r1,r1,#30
00000a  0e09              LSRS     r1,r1,#24
00000c  4099              LSLS     r1,r1,r3
00000e  2800              CMP      r0,#0                 ;584
000010  da0b              BGE      |L1.42|
000012  0700              LSLS     r0,r0,#28
000014  0f00              LSRS     r0,r0,#28
000016  3808              SUBS     r0,r0,#8
000018  0883              LSRS     r3,r0,#2
00001a  48fb              LDR      r0,|L1.1032|
00001c  009b              LSLS     r3,r3,#2
00001e  1818              ADDS     r0,r3,r0
000020  69c3              LDR      r3,[r0,#0x1c]
000022  4393              BICS     r3,r3,r2
000024  430b              ORRS     r3,r3,r1
000026  61c3              STR      r3,[r0,#0x1c]
;;;586            (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
;;;587      else {
;;;588        NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
;;;589            (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
;;;590    }
000028  4770              BX       lr
                  |L1.42|
00002a  0883              LSRS     r3,r0,#2              ;588
00002c  48f7              LDR      r0,|L1.1036|
00002e  009b              LSLS     r3,r3,#2              ;588
000030  181b              ADDS     r3,r3,r0              ;588
000032  6818              LDR      r0,[r3,#0]            ;588
000034  4390              BICS     r0,r0,r2              ;588
000036  4308              ORRS     r0,r0,r1              ;588
000038  6018              STR      r0,[r3,#0]            ;588
00003a  4770              BX       lr
;;;591    
                          ENDP

                  timer_list_insert PROC
;;;218     */
;;;219    static void timer_list_insert(app_timer_id_t timer_id)
00003c  b5f0              PUSH     {r4-r7,lr}
;;;220    {
;;;221        timer_node_t * p_timer = &mp_nodes[timer_id];
00003e  4ff4              LDR      r7,|L1.1040|
000040  2124              MOVS     r1,#0x24
000042  687c              LDR      r4,[r7,#4]  ; mp_nodes
000044  4341              MULS     r1,r0,r1
000046  190d              ADDS     r5,r1,r4
;;;222        
;;;223        if (m_timer_id_head == TIMER_NULL)
000048  6939              LDR      r1,[r7,#0x10]  ; m_timer_id_head
00004a  1c4a              ADDS     r2,r1,#1
00004c  d009              BEQ      |L1.98|
;;;224        {
;;;225            m_timer_id_head = timer_id;
;;;226        }
;;;227        else
;;;228        {
;;;229            if (p_timer->ticks_to_expire <= mp_nodes[m_timer_id_head].ticks_to_expire)
00004e  2224              MOVS     r2,#0x24
000050  434a              MULS     r2,r1,r2
000052  1916              ADDS     r6,r2,r4
000054  686b              LDR      r3,[r5,#4]
000056  6872              LDR      r2,[r6,#4]
000058  4293              CMP      r3,r2
00005a  d804              BHI      |L1.102|
;;;230            {
;;;231                mp_nodes[m_timer_id_head].ticks_to_expire -= p_timer->ticks_to_expire;
00005c  1ad2              SUBS     r2,r2,r3
;;;232                
;;;233                p_timer->next   = m_timer_id_head;
00005e  6072              STR      r2,[r6,#4]
000060  6229              STR      r1,[r5,#0x20]
                  |L1.98|
000062  6138              STR      r0,[r7,#0x10]         ;225  ; m_timer_id_head
;;;234                m_timer_id_head = timer_id;
;;;235            }
;;;236            else
;;;237            {
;;;238                app_timer_id_t previous;
;;;239                app_timer_id_t current;
;;;240                uint32_t       ticks_to_expire;
;;;241    
;;;242                ticks_to_expire = p_timer->ticks_to_expire;
;;;243                previous        = m_timer_id_head;
;;;244                current         = m_timer_id_head;
;;;245                
;;;246                while ((current != TIMER_NULL) && (ticks_to_expire > mp_nodes[current].ticks_to_expire))
;;;247                {
;;;248                    ticks_to_expire -= mp_nodes[current].ticks_to_expire;
;;;249                    previous         = current;
;;;250                    current          = mp_nodes[current].next;
;;;251                }
;;;252    
;;;253                if (current != TIMER_NULL)
;;;254                {
;;;255                    mp_nodes[current].ticks_to_expire -= ticks_to_expire;
;;;256                }
;;;257    
;;;258                p_timer->ticks_to_expire = ticks_to_expire;
;;;259                p_timer->next            = current;
;;;260                mp_nodes[previous].next  = timer_id;
;;;261            }
;;;262        }
;;;263    }
000064  bdf0              POP      {r4-r7,pc}
                  |L1.102|
000066  460a              MOV      r2,r1                 ;243
000068  e002              B        |L1.112|
                  |L1.106|
00006a  460a              MOV      r2,r1                 ;249
00006c  6a39              LDR      r1,[r7,#0x20]         ;250
00006e  1b9b              SUBS     r3,r3,r6              ;248
                  |L1.112|
000070  1c4e              ADDS     r6,r1,#1              ;246
000072  d00b              BEQ      |L1.140|
000074  2624              MOVS     r6,#0x24              ;246
000076  434e              MULS     r6,r1,r6              ;246
000078  1937              ADDS     r7,r6,r4              ;246
00007a  687e              LDR      r6,[r7,#4]            ;246
00007c  429e              CMP      r6,r3                 ;246
00007e  d3f4              BCC      |L1.106|
000080  2624              MOVS     r6,#0x24              ;255
000082  434e              MULS     r6,r1,r6              ;255
000084  1936              ADDS     r6,r6,r4              ;255
000086  6877              LDR      r7,[r6,#4]            ;255
000088  1aff              SUBS     r7,r7,r3              ;255
00008a  6077              STR      r7,[r6,#4]            ;255
                  |L1.140|
00008c  606b              STR      r3,[r5,#4]            ;260
00008e  6229              STR      r1,[r5,#0x20]         ;260
000090  2124              MOVS     r1,#0x24              ;260
000092  434a              MULS     r2,r1,r2              ;260
000094  1911              ADDS     r1,r2,r4              ;260
000096  6208              STR      r0,[r1,#0x20]         ;260
000098  bdf0              POP      {r4-r7,pc}
;;;264    
                          ENDP

                  timer_timeouts_check PROC
;;;353     */
;;;354    static void timer_timeouts_check(void)
00009a  b5f8              PUSH     {r3-r7,lr}
;;;355    {
;;;356        // Handle expired of timer 
;;;357        if (m_timer_id_head != TIMER_NULL)
00009c  4cdc              LDR      r4,|L1.1040|
00009e  6925              LDR      r5,[r4,#0x10]  ; m_timer_id_head
0000a0  1c68              ADDS     r0,r5,#1
0000a2  d036              BEQ      |L1.274|
0000a4  48db              LDR      r0,|L1.1044|
;;;358        {
;;;359            app_timer_id_t  timer_id;
;;;360            uint32_t        ticks_elapsed;
;;;361            uint32_t        ticks_expired;
;;;362    
;;;363            // Initialize actual elapsed ticks being consumed to 0 
;;;364            ticks_expired = 0;
0000a6  2600              MOVS     r6,#0
0000a8  6840              LDR      r0,[r0,#4]
0000aa  6961              LDR      r1,[r4,#0x14]  ; m_ticks_latest
0000ac  1a40              SUBS     r0,r0,r1
0000ae  0207              LSLS     r7,r0,#8
0000b0  0a3f              LSRS     r7,r7,#8
;;;365    
;;;366            // ticks_elapsed is collected here, job will use it
;;;367            ticks_elapsed = ticks_diff_get(rtc1_counter_get(), m_ticks_latest);
;;;368    
;;;369            // Auto variable containing the head of timers expiring 
;;;370            timer_id = m_timer_id_head;
;;;371    
;;;372            // Expire all timers within ticks_elapsed and collect ticks_expired 
;;;373            while (timer_id != TIMER_NULL)
0000b2  e01a              B        |L1.234|
                  |L1.180|
;;;374            {
;;;375                timer_node_t * p_timer;
;;;376    
;;;377                // Auto variable for current timer node 
;;;378                p_timer = &mp_nodes[timer_id];
0000b4  2024              MOVS     r0,#0x24
0000b6  4345              MULS     r5,r0,r5
0000b8  6860              LDR      r0,[r4,#4]  ; mp_nodes
0000ba  182a              ADDS     r2,r5,r0
;;;379    
;;;380                // Do nothing if timer did not expire 
;;;381                if (ticks_elapsed < p_timer->ticks_to_expire)
0000bc  6850              LDR      r0,[r2,#4]
0000be  42b8              CMP      r0,r7
0000c0  d815              BHI      |L1.238|
0000c2  69a3              LDR      r3,[r4,#0x18]  ; m_evt_schedule_func
;;;382                {
;;;383                    break;
;;;384                }
;;;385    
;;;386                // Decrement ticks_elapsed and collect expired ticks 
;;;387                ticks_elapsed -= p_timer->ticks_to_expire;
0000c4  1a3f              SUBS     r7,r7,r0
;;;388                ticks_expired += p_timer->ticks_to_expire;
0000c6  1986              ADDS     r6,r0,r6
0000c8  6a15              LDR      r5,[r2,#0x20]
0000ca  2b00              CMP      r3,#0
0000cc  d00a              BEQ      |L1.228|
0000ce  69d1              LDR      r1,[r2,#0x1c]
0000d0  6990              LDR      r0,[r2,#0x18]
0000d2  4798              BLX      r3
0000d4  2800              CMP      r0,#0
0000d6  d008              BEQ      |L1.234|
0000d8  21ff              MOVS     r1,#0xff
0000da  a2cf              ADR      r2,|L1.1048|
0000dc  3158              ADDS     r1,r1,#0x58
0000de  f7fffffe          BL       app_error_handler
0000e2  e002              B        |L1.234|
                  |L1.228|
0000e4  6991              LDR      r1,[r2,#0x18]
0000e6  69d0              LDR      r0,[r2,#0x1c]
0000e8  4788              BLX      r1
                  |L1.234|
0000ea  1c68              ADDS     r0,r5,#1              ;373
0000ec  d1e2              BNE      |L1.180|
                  |L1.238|
;;;389    
;;;390                // Move to next timer 
;;;391                timer_id = p_timer->next;
;;;392    
;;;393                // Execute Task 
;;;394                timeout_handler_exec(p_timer);
;;;395            }
;;;396    
;;;397            // Prepare to queue the ticks expired in the m_ticks_elapsed queue.
;;;398            if (m_ticks_elapsed_q_read_ind == m_ticks_elapsed_q_write_ind)
0000ee  78a1              LDRB     r1,[r4,#2]  ; m_ticks_elapsed_q_read_ind
0000f0  78e0              LDRB     r0,[r4,#3]  ; m_ticks_elapsed_q_write_ind
0000f2  4281              CMP      r1,r0
0000f4  d106              BNE      |L1.260|
0000f6  1c40              ADDS     r0,r0,#1
;;;399            {
;;;400                // The read index of the queue is equal to the write index. This means the new
;;;401                // value of ticks_expired should be stored at a new location in the m_ticks_elapsed
;;;402                // queue (which is implemented as a double buffer).
;;;403    
;;;404                // Check if there will be a queue overflow.
;;;405                if (++m_ticks_elapsed_q_write_ind == CONTEXT_QUEUE_SIZE_MAX)
0000f8  b2c0              UXTB     r0,r0
0000fa  70e0              STRB     r0,[r4,#3]
0000fc  2802              CMP      r0,#2
0000fe  d101              BNE      |L1.260|
;;;406                {
;;;407                    // There will be a queue overflow. Hence the write index should point to the start
;;;408                    // of the queue.
;;;409                    m_ticks_elapsed_q_write_ind = 0;
000100  2000              MOVS     r0,#0
000102  70e0              STRB     r0,[r4,#3]
                  |L1.260|
;;;410                }
;;;411            }
;;;412    
;;;413            // Queue the ticks expired.
;;;414            m_ticks_elapsed[m_ticks_elapsed_q_write_ind] = ticks_expired;
000104  49c2              LDR      r1,|L1.1040|
000106  0600              LSLS     r0,r0,#24
000108  0d80              LSRS     r0,r0,#22
00010a  311c              ADDS     r1,r1,#0x1c
00010c  500e              STR      r6,[r1,r0]
;;;415    
;;;416            timer_list_handler_sched();
00010e  f7fffffe          BL       timer_list_handler_sched
                  |L1.274|
;;;417        }
;;;418    }
000112  bdf8              POP      {r3-r7,pc}
;;;419    
                          ENDP

                  list_insertions_handler PROC
;;;576     */
;;;577    static bool list_insertions_handler(app_timer_id_t restart_list_head)
000114  b5f8              PUSH     {r3-r7,lr}
;;;578    {
000116  4604              MOV      r4,r0
;;;579        app_timer_id_t timer_id_old_head;
;;;580        uint8_t        user_id;
;;;581    
;;;582        // Remember the old head, so as to decide if new compare needs to be set
;;;583        timer_id_old_head = m_timer_id_head;
000118  48bd              LDR      r0,|L1.1040|
00011a  6901              LDR      r1,[r0,#0x10]  ; m_timer_id_head
;;;584    
;;;585        user_id = m_user_array_size;
00011c  9100              STR      r1,[sp,#0]
00011e  7846              LDRB     r6,[r0,#1]  ; m_user_array_size
000120  e056              B        |L1.464|
                  |L1.290|
;;;586        while (user_id--)
;;;587        {
;;;588            timer_user_t * p_user = &mp_users[user_id];
000122  48bb              LDR      r0,|L1.1040|
000124  00f1              LSLS     r1,r6,#3              ;578
000126  68c2              LDR      r2,[r0,#0xc]  ; mp_users
000128  188d              ADDS     r5,r1,r2
;;;589    
;;;590            // Handle insertions of timers 
;;;591            while ((restart_list_head != TIMER_NULL) || (p_user->first != p_user->last))
00012a  e04b              B        |L1.452|
                  |L1.300|
;;;592            {
;;;593                app_timer_id_t id_start;
;;;594                timer_node_t * p_timer;
;;;595    
;;;596                if (restart_list_head != TIMER_NULL)
00012c  1c60              ADDS     r0,r4,#1
00012e  d007              BEQ      |L1.320|
;;;597                {
;;;598                    id_start          = restart_list_head;
;;;599                    p_timer           = &mp_nodes[id_start];
000130  4ab7              LDR      r2,|L1.1040|
000132  2124              MOVS     r1,#0x24
000134  6852              LDR      r2,[r2,#4]  ; mp_nodes
000136  4361              MULS     r1,r4,r1
000138  4620              MOV      r0,r4                 ;598
00013a  1889              ADDS     r1,r1,r2
;;;600                    restart_list_head = p_timer->next;
00013c  6a0c              LDR      r4,[r1,#0x20]
00013e  e020              B        |L1.386|
                  |L1.320|
;;;601                }
;;;602                else
;;;603                {
;;;604                    timer_user_op_t * p_user_op = &p_user->p_user_op_queue[p_user->first];
000140  7828              LDRB     r0,[r5,#0]
000142  2118              MOVS     r1,#0x18
000144  4341              MULS     r1,r0,r1
000146  686a              LDR      r2,[r5,#4]
000148  1c40              ADDS     r0,r0,#1
;;;605    
;;;606                    p_user->first++;
00014a  b2c0              UXTB     r0,r0
00014c  1852              ADDS     r2,r2,r1              ;604
00014e  7028              STRB     r0,[r5,#0]
;;;607                    if (p_user->first == p_user->user_op_queue_size)
000150  78a9              LDRB     r1,[r5,#2]
000152  4288              CMP      r0,r1
000154  d101              BNE      |L1.346|
;;;608                    {
;;;609                        p_user->first = 0;
000156  2000              MOVS     r0,#0
000158  7028              STRB     r0,[r5,#0]
                  |L1.346|
;;;610                    }
;;;611    
;;;612                    id_start = p_user_op->timer_id;
;;;613                    p_timer  = &mp_nodes[id_start];
00015a  4bad              LDR      r3,|L1.1040|
00015c  6850              LDR      r0,[r2,#4]
00015e  2124              MOVS     r1,#0x24
000160  685b              LDR      r3,[r3,#4]  ; mp_nodes
000162  4341              MULS     r1,r0,r1
000164  18c9              ADDS     r1,r1,r3
;;;614    
;;;615                    if ((p_user_op->op_type != TIMER_USER_OP_TYPE_START) || p_timer->is_running)
000166  7813              LDRB     r3,[r2,#0]
000168  2b01              CMP      r3,#1
00016a  d12d              BNE      |L1.456|
00016c  7d0b              LDRB     r3,[r1,#0x14]
00016e  2b00              CMP      r3,#0
000170  d12a              BNE      |L1.456|
;;;616                    {
;;;617                        continue;
;;;618                    }
;;;619    
;;;620                    p_timer->ticks_at_start          = p_user_op->params.start.ticks_at_start;
000172  6893              LDR      r3,[r2,#8]
;;;621                    p_timer->ticks_first_interval    = p_user_op->params.start.ticks_first_interval;
000174  608b              STR      r3,[r1,#8]
000176  68d3              LDR      r3,[r2,#0xc]
;;;622                    p_timer->ticks_periodic_interval = p_user_op->params.start.ticks_periodic_interval;
000178  60cb              STR      r3,[r1,#0xc]
00017a  6913              LDR      r3,[r2,#0x10]
;;;623                    p_timer->p_context               = p_user_op->params.start.p_context;
00017c  610b              STR      r3,[r1,#0x10]
00017e  6952              LDR      r2,[r2,#0x14]
000180  61ca              STR      r2,[r1,#0x1c]
                  |L1.386|
;;;624                }
;;;625    
;;;626                // Prepare the node to be inserted 
;;;627                if (
000182  4aa3              LDR      r2,|L1.1040|
000184  688f              LDR      r7,[r1,#8]
000186  6953              LDR      r3,[r2,#0x14]  ; m_ticks_latest
000188  46bc              MOV      r12,r7
00018a  1afa              SUBS     r2,r7,r3
00018c  0212              LSLS     r2,r2,#8
00018e  4fab              LDR      r7,|L1.1084|
000190  0a12              LSRS     r2,r2,#8
000192  42ba              CMP      r2,r7
000194  d202              BCS      |L1.412|
;;;628                     ((p_timer->ticks_at_start - m_ticks_latest) & MAX_RTC_COUNTER_VAL)
;;;629                     <
;;;630                     (MAX_RTC_COUNTER_VAL / 2)
;;;631                    )
;;;632                {
;;;633                    p_timer->ticks_to_expire = ticks_diff_get(p_timer->ticks_at_start, m_ticks_latest) + 
000196  68cb              LDR      r3,[r1,#0xc]
000198  18d2              ADDS     r2,r2,r3
00019a  e009              B        |L1.432|
                  |L1.412|
00019c  4662              MOV      r2,r12
;;;634                                               p_timer->ticks_first_interval;
;;;635                }
;;;636                else
;;;637                {
;;;638                    uint32_t delta_current_start;
;;;639    
;;;640                    delta_current_start = ticks_diff_get(m_ticks_latest, p_timer->ticks_at_start);
00019e  1a9a              SUBS     r2,r3,r2
0001a0  0212              LSLS     r2,r2,#8
;;;641                    if (p_timer->ticks_first_interval > delta_current_start)
0001a2  68cb              LDR      r3,[r1,#0xc]
0001a4  0a12              LSRS     r2,r2,#8              ;640
0001a6  4293              CMP      r3,r2
0001a8  d901              BLS      |L1.430|
;;;642                    {
;;;643                        p_timer->ticks_to_expire = p_timer->ticks_first_interval - delta_current_start;
0001aa  1a9a              SUBS     r2,r3,r2
0001ac  e000              B        |L1.432|
                  |L1.430|
;;;644                    }
;;;645                    else
;;;646                    {
;;;647                        p_timer->ticks_to_expire = 0;
0001ae  2200              MOVS     r2,#0
                  |L1.432|
;;;648                    }
;;;649                }
;;;650    
;;;651                p_timer->ticks_at_start       = 0;
0001b0  604a              STR      r2,[r1,#4]
0001b2  2200              MOVS     r2,#0
;;;652                p_timer->ticks_first_interval = 0;
0001b4  608a              STR      r2,[r1,#8]
;;;653                p_timer->is_running           = true;
0001b6  60ca              STR      r2,[r1,#0xc]
0001b8  2201              MOVS     r2,#1
0001ba  750a              STRB     r2,[r1,#0x14]
;;;654                p_timer->next                 = TIMER_NULL;
0001bc  1e92              SUBS     r2,r2,#2
;;;655    
;;;656                // Insert into list 
;;;657                timer_list_insert(id_start);
0001be  620a              STR      r2,[r1,#0x20]
0001c0  f7fffffe          BL       timer_list_insert
                  |L1.452|
0001c4  1c60              ADDS     r0,r4,#1              ;591
0001c6  d1b1              BNE      |L1.300|
                  |L1.456|
0001c8  7828              LDRB     r0,[r5,#0]            ;591
0001ca  7869              LDRB     r1,[r5,#1]            ;591
0001cc  4288              CMP      r0,r1                 ;591
0001ce  d1ad              BNE      |L1.300|
                  |L1.464|
0001d0  4630              MOV      r0,r6                 ;586
0001d2  1e76              SUBS     r6,r6,#1              ;586
0001d4  b2f6              UXTB     r6,r6                 ;586
0001d6  2800              CMP      r0,#0                 ;586
0001d8  d1a3              BNE      |L1.290|
;;;658            }
;;;659        }
;;;660        
;;;661        return (m_timer_id_head != timer_id_old_head);
0001da  488d              LDR      r0,|L1.1040|
0001dc  6901              LDR      r1,[r0,#0x10]  ; m_timer_id_head
0001de  9800              LDR      r0,[sp,#0]
0001e0  4281              CMP      r1,r0
0001e2  d001              BEQ      |L1.488|
0001e4  2001              MOVS     r0,#1
;;;662    }
0001e6  bdf8              POP      {r3-r7,pc}
                  |L1.488|
0001e8  2000              MOVS     r0,#0                 ;661
0001ea  bdf8              POP      {r3-r7,pc}
;;;663    
                          ENDP

                  RTC1_IRQHandler PROC
;;;892     */
;;;893    void RTC1_IRQHandler(void)
0001ec  4994              LDR      r1,|L1.1088|
;;;894    {
;;;895    	  static uint32_t count;
;;;896        // Clear all events (also unexpected ones)
;;;897       NRF_RTC1->EVENTS_COMPARE[0] = 0;
0001ee  2000              MOVS     r0,#0
0001f0  6008              STR      r0,[r1,#0]
;;;898        NRF_RTC1->EVENTS_COMPARE[1] = 0;
0001f2  6048              STR      r0,[r1,#4]
;;;899        NRF_RTC1->EVENTS_COMPARE[2] = 0;
0001f4  6088              STR      r0,[r1,#8]
;;;900        NRF_RTC1->EVENTS_COMPARE[3] = 0;
0001f6  60c8              STR      r0,[r1,#0xc]
;;;901        NRF_RTC1->EVENTS_TICK       = 0;
0001f8  4991              LDR      r1,|L1.1088|
0001fa  3940              SUBS     r1,r1,#0x40
0001fc  6008              STR      r0,[r1,#0]
;;;902        NRF_RTC1->EVENTS_OVRFLW     = 0;
0001fe  6048              STR      r0,[r1,#4]
;;;903    	  count++;
000200  4983              LDR      r1,|L1.1040|
;;;904    	  if(count==768)
000202  2303              MOVS     r3,#3
000204  688a              LDR      r2,[r1,#8]            ;903  ; count
000206  021b              LSLS     r3,r3,#8
000208  1c52              ADDS     r2,r2,#1              ;903
00020a  608a              STR      r2,[r1,#8]  ; count
00020c  429a              CMP      r2,r3
00020e  d100              BNE      |L1.530|
;;;905    		{
;;;906    		count=0;
000210  6088              STR      r0,[r1,#8]  ; count
                  |L1.530|
;;;907        //nrf_gpio_pin_toggle(LED_0);
;;;908    	  //nrf_gpio_pin_toggle(LED_1);
;;;909    		}
;;;910        // Check for expired timers
;;;911        timer_timeouts_check();
000212  e7fe              B        timer_timeouts_check
;;;912    }
;;;913    
                          ENDP

                  SWI0_IRQHandler PROC
;;;918     */
;;;919    void SWI0_IRQHandler(void)
000214  b5f0              PUSH     {r4-r7,lr}
000216  2000              MOVS     r0,#0
;;;920    {
000218  b087              SUB      sp,sp,#0x1c
00021a  43c0              MVNS     r0,r0
00021c  9002              STR      r0,[sp,#8]
00021e  487c              LDR      r0,|L1.1040|
000220  6946              LDR      r6,[r0,#0x14]  ; m_ticks_latest
000222  6905              LDR      r5,[r0,#0x10]  ; m_timer_id_head
000224  4668              MOV      r0,sp
000226  f7fffffe          BL       elapsed_ticks_acquire
00022a  4607              MOV      r7,r0
00022c  f7fffffe          BL       list_deletions_handler
000230  4604              MOV      r4,r0
000232  2f00              CMP      r7,#0
000234  d008              BEQ      |L1.584|
000236  aa02              ADD      r2,sp,#8
000238  4631              MOV      r1,r6
00023a  9800              LDR      r0,[sp,#0]
00023c  f7fffffe          BL       expired_timers_handler
000240  9802              LDR      r0,[sp,#8]
000242  f7fffffe          BL       list_insertions_handler
000246  e006              B        |L1.598|
                  |L1.584|
000248  9802              LDR      r0,[sp,#8]
00024a  f7fffffe          BL       list_insertions_handler
00024e  2800              CMP      r0,#0
000250  d101              BNE      |L1.598|
000252  2c00              CMP      r4,#0
000254  d002              BEQ      |L1.604|
                  |L1.598|
000256  4628              MOV      r0,r5
000258  f7fffffe          BL       compare_reg_update
                  |L1.604|
;;;921        timer_list_handler();
;;;922    }
00025c  b007              ADD      sp,sp,#0x1c
00025e  bdf0              POP      {r4-r7,pc}
;;;923    
                          ENDP

                  app_timer_init PROC
;;;924    
;;;925    uint32_t app_timer_init(uint32_t                      prescaler,
000260  b5ff              PUSH     {r0-r7,lr}
000262  0798              LSLS     r0,r3,#30
000264  2400              MOVS     r4,#0
;;;926                            uint8_t                       max_timers,
;;;927                            uint8_t                       op_queues_size,
;;;928                            void *                        p_buffer,
;;;929                            app_timer_evt_schedule_func_t evt_schedule_func)
;;;930    {
000266  b081              SUB      sp,sp,#4
000268  461e              MOV      r6,r3
00026a  4615              MOV      r5,r2
00026c  460f              MOV      r7,r1
00026e  2800              CMP      r0,#0
000270  d10b              BNE      |L1.650|
;;;931        int i;
;;;932    
;;;933        // Check that buffer is correctly aligned
;;;934        if (!is_word_aligned(p_buffer))
;;;935        {
;;;936            return NRF_ERROR_INVALID_PARAM;
;;;937        }
;;;938        // Check for NULL buffer
;;;939        if (p_buffer == NULL)
000272  2e00              CMP      r6,#0
000274  d009              BEQ      |L1.650|
;;;940        {
;;;941            return NRF_ERROR_INVALID_PARAM;
;;;942        }
;;;943        
;;;944        // Stop RTC to prevent any running timers from expiring (in case of reinitialization)
;;;945        rtc1_stop();
000276  f7fffffe          BL       rtc1_stop
;;;946        
;;;947        m_evt_schedule_func = evt_schedule_func;
00027a  4965              LDR      r1,|L1.1040|
00027c  980a              LDR      r0,[sp,#0x28]
;;;948    
;;;949        // Initialize timer node array
;;;950        m_node_array_size = max_timers;
00027e  6188              STR      r0,[r1,#0x18]  ; m_evt_schedule_func
000280  700f              STRB     r7,[r1,#0]
;;;951        mp_nodes          = p_buffer;
000282  4632              MOV      r2,r6
;;;952        
;;;953        for (i = 0; i < max_timers; i++)
000284  2000              MOVS     r0,#0
000286  604e              STR      r6,[r1,#4]  ; mp_nodes
000288  e008              B        |L1.668|
                  |L1.650|
00028a  2007              MOVS     r0,#7                 ;936
                  |L1.652|
;;;954        {
;;;955            mp_nodes[i].state      = STATE_FREE;
;;;956            mp_nodes[i].is_running = false;
;;;957        }
;;;958        
;;;959        // Skip timer node array
;;;960        p_buffer = &((uint8_t *)p_buffer)[max_timers * sizeof(timer_node_t)];
;;;961        
;;;962        // Initialize users array
;;;963        m_user_array_size = APP_TIMER_INT_LEVELS;
;;;964        mp_users          = p_buffer;
;;;965        
;;;966        // Skip user array
;;;967        p_buffer = &((uint8_t *)p_buffer)[APP_TIMER_INT_LEVELS * sizeof(timer_user_t)];
;;;968    
;;;969        // Initialize operation queues
;;;970        for (i = 0; i < APP_TIMER_INT_LEVELS; i++)
;;;971        {
;;;972            timer_user_t * p_user = &mp_users[i];
;;;973            
;;;974            p_user->first              = 0;
;;;975            p_user->last               = 0;
;;;976            p_user->user_op_queue_size = op_queues_size;
;;;977            p_user->p_user_op_queue    = p_buffer;
;;;978        
;;;979            // Skip operation queue
;;;980            p_buffer = &((uint8_t *)p_buffer)[op_queues_size * sizeof(timer_user_op_t)];
;;;981        }
;;;982    
;;;983        m_timer_id_head             = TIMER_NULL;
;;;984        m_ticks_elapsed_q_read_ind  = 0;
;;;985        m_ticks_elapsed_q_write_ind = 0;
;;;986    
;;;987        NVIC_ClearPendingIRQ(SWI0_IRQn);
;;;988        NVIC_SetPriority(SWI0_IRQn, SWI0_IRQ_PRI);
;;;989        NVIC_EnableIRQ(SWI0_IRQn);
;;;990    
;;;991        rtc1_init(prescaler);
;;;992    
;;;993        m_ticks_latest = rtc1_counter_get();
;;;994        
;;;995        return NRF_SUCCESS;
;;;996    }
00028c  b005              ADD      sp,sp,#0x14
00028e  bdf0              POP      {r4-r7,pc}
                  |L1.656|
000290  2324              MOVS     r3,#0x24              ;955
000292  4343              MULS     r3,r0,r3              ;955
000294  54d4              STRB     r4,[r2,r3]            ;955
000296  189b              ADDS     r3,r3,r2              ;956
000298  751c              STRB     r4,[r3,#0x14]         ;956
00029a  1c40              ADDS     r0,r0,#1              ;956
                  |L1.668|
00029c  42b8              CMP      r0,r7                 ;953
00029e  dbf7              BLT      |L1.656|
0002a0  2024              MOVS     r0,#0x24              ;960
0002a2  4347              MULS     r7,r0,r7              ;960
0002a4  19bb              ADDS     r3,r7,r6              ;960
0002a6  2003              MOVS     r0,#3                 ;963
0002a8  7048              STRB     r0,[r1,#1]            ;963
0002aa  460f              MOV      r7,r1                 ;963
0002ac  4618              MOV      r0,r3                 ;967
0002ae  60cb              STR      r3,[r1,#0xc]          ;970  ; mp_users
0002b0  4619              MOV      r1,r3                 ;970
0002b2  3018              ADDS     r0,r0,#0x18           ;967
0002b4  2200              MOVS     r2,#0                 ;970
0002b6  2318              MOVS     r3,#0x18              ;980
0002b8  462e              MOV      r6,r5                 ;980
0002ba  435e              MULS     r6,r3,r6              ;980
                  |L1.700|
0002bc  00d3              LSLS     r3,r2,#3              ;980
0002be  185b              ADDS     r3,r3,r1              ;972
0002c0  701c              STRB     r4,[r3,#0]            ;974
0002c2  705c              STRB     r4,[r3,#1]            ;975
0002c4  709d              STRB     r5,[r3,#2]            ;976
0002c6  6058              STR      r0,[r3,#4]            ;980
0002c8  1830              ADDS     r0,r6,r0              ;980
0002ca  1c52              ADDS     r2,r2,#1              ;980
0002cc  2a03              CMP      r2,#3                 ;970
0002ce  dbf5              BLT      |L1.700|
0002d0  2000              MOVS     r0,#0                 ;983
0002d2  43c0              MVNS     r0,r0                 ;983
0002d4  6138              STR      r0,[r7,#0x10]         ;984  ; m_timer_id_head
0002d6  70bc              STRB     r4,[r7,#2]            ;984
0002d8  70fc              STRB     r4,[r7,#3]            ;985
0002da  2401              MOVS     r4,#1                 ;985
0002dc  4859              LDR      r0,|L1.1092|
0002de  0524              LSLS     r4,r4,#20             ;985
0002e0  6004              STR      r4,[r0,#0]            ;985
0002e2  2103              MOVS     r1,#3                 ;988
0002e4  2014              MOVS     r0,#0x14              ;988
0002e6  f7fffffe          BL       NVIC_SetPriority
0002ea  4857              LDR      r0,|L1.1096|
0002ec  6004              STR      r4,[r0,#0]            ;988
0002ee  4c49              LDR      r4,|L1.1044|
0002f0  9801              LDR      r0,[sp,#4]            ;988
0002f2  60a0              STR      r0,[r4,#8]            ;988
0002f4  2103              MOVS     r1,#3                 ;988
0002f6  2011              MOVS     r0,#0x11              ;988
0002f8  f7fffffe          BL       NVIC_SetPriority
0002fc  6860              LDR      r0,[r4,#4]            ;988
0002fe  6178              STR      r0,[r7,#0x14]         ;995  ; m_ticks_latest
000300  2000              MOVS     r0,#0                 ;995
000302  e7c3              B        |L1.652|
;;;997    
                          ENDP

                  app_timer_create PROC
;;;998    
;;;999    uint32_t app_timer_create(app_timer_id_t *            p_timer_id,
000304  b570              PUSH     {r4-r6,lr}
;;;1000                             app_timer_mode_t            mode,
;;;1001                             app_timer_timeout_handler_t timeout_handler)
;;;1002   {
;;;1003       int i;
;;;1004   
;;;1005       // Check state and parameters
;;;1006       if (mp_nodes == NULL)
000306  4c42              LDR      r4,|L1.1040|
000308  6865              LDR      r5,[r4,#4]  ; mp_nodes
00030a  2d00              CMP      r5,#0
00030c  d006              BEQ      |L1.796|
;;;1007       {
;;;1008           return NRF_ERROR_INVALID_STATE;
;;;1009       }
;;;1010       if (timeout_handler == NULL)
00030e  2a00              CMP      r2,#0
000310  d006              BEQ      |L1.800|
;;;1011       {
;;;1012           return NRF_ERROR_INVALID_PARAM;
;;;1013       }
;;;1014       if (p_timer_id == NULL)
000312  2800              CMP      r0,#0
000314  d004              BEQ      |L1.800|
;;;1015       {
;;;1016           return NRF_ERROR_INVALID_PARAM;
;;;1017       }    
;;;1018       
;;;1019       // Find free timer
;;;1020       for (i = 0; i < m_node_array_size; i++)
000316  2300              MOVS     r3,#0
000318  7824              LDRB     r4,[r4,#0]
00031a  e009              B        |L1.816|
                  |L1.796|
00031c  2008              MOVS     r0,#8                 ;1008
;;;1021       {
;;;1022           if (mp_nodes[i].state == STATE_FREE)
;;;1023           {
;;;1024               mp_nodes[i].state             = STATE_ALLOCATED;
;;;1025               mp_nodes[i].mode              = mode;
;;;1026               mp_nodes[i].p_timeout_handler = timeout_handler;
;;;1027               
;;;1028               *p_timer_id = i;
;;;1029               return NRF_SUCCESS;
;;;1030           }
;;;1031       }
;;;1032       
;;;1033       return NRF_ERROR_NO_MEM;
;;;1034   }
00031e  bd70              POP      {r4-r6,pc}
                  |L1.800|
000320  2007              MOVS     r0,#7                 ;1016
000322  bd70              POP      {r4-r6,pc}
                  |L1.804|
000324  2624              MOVS     r6,#0x24              ;1022
000326  435e              MULS     r6,r3,r6              ;1022
000328  5dae              LDRB     r6,[r5,r6]            ;1022
00032a  2e00              CMP      r6,#0                 ;1022
00032c  d004              BEQ      |L1.824|
00032e  1c5b              ADDS     r3,r3,#1              ;1022
                  |L1.816|
000330  42a3              CMP      r3,r4                 ;1020
000332  dbf7              BLT      |L1.804|
000334  2004              MOVS     r0,#4                 ;1033
000336  bd70              POP      {r4-r6,pc}
                  |L1.824|
000338  2424              MOVS     r4,#0x24              ;1024
00033a  2601              MOVS     r6,#1                 ;1024
00033c  435c              MULS     r4,r3,r4              ;1024
00033e  552e              STRB     r6,[r5,r4]            ;1024
000340  1964              ADDS     r4,r4,r5              ;1025
000342  7061              STRB     r1,[r4,#1]            ;1025
000344  61a2              STR      r2,[r4,#0x18]         ;1028
000346  6003              STR      r3,[r0,#0]            ;1029
000348  2000              MOVS     r0,#0                 ;1029
00034a  bd70              POP      {r4-r6,pc}
;;;1035   
                          ENDP

                  user_id_get PROC
;;;1040   */
;;;1041   static timer_user_id_t user_id_get(void)
00034c  492e              LDR      r1,|L1.1032|
00034e  6848              LDR      r0,[r1,#4]
000350  05c0              LSLS     r0,r0,#23
000352  0dc0              LSRS     r0,r0,#23
;;;1042   {
000354  d019              BEQ      |L1.906|
000356  3810              SUBS     r0,r0,#0x10
000358  b240              SXTB     r0,r0
00035a  2800              CMP      r0,#0
00035c  da07              BGE      |L1.878|
00035e  0702              LSLS     r2,r0,#28
000360  0f12              LSRS     r2,r2,#28
000362  3a08              SUBS     r2,r2,#8
000364  0892              LSRS     r2,r2,#2
000366  0092              LSLS     r2,r2,#2
000368  1851              ADDS     r1,r2,r1
00036a  69c9              LDR      r1,[r1,#0x1c]
00036c  e004              B        |L1.888|
                  |L1.878|
00036e  0881              LSRS     r1,r0,#2
000370  4a26              LDR      r2,|L1.1036|
000372  0089              LSLS     r1,r1,#2
000374  1889              ADDS     r1,r1,r2
000376  6809              LDR      r1,[r1,#0]
                  |L1.888|
000378  0780              LSLS     r0,r0,#30
00037a  0ec0              LSRS     r0,r0,#27
00037c  40c1              LSRS     r1,r1,r0
00037e  0608              LSLS     r0,r1,#24
000380  0f80              LSRS     r0,r0,#30
;;;1043       timer_user_id_t ret;
;;;1044   
;;;1045       STATIC_ASSERT(APP_TIMER_INT_LEVELS == 3);
;;;1046       
;;;1047       switch (current_int_priority_get())
000382  2801              CMP      r0,#1
000384  d003              BEQ      |L1.910|
000386  2803              CMP      r0,#3
000388  d003              BEQ      |L1.914|
                  |L1.906|
;;;1048       {
;;;1049           case APP_IRQ_PRIORITY_HIGH:
;;;1050               ret = APP_HIGH_USER_ID;
;;;1051               break;
;;;1052               
;;;1053           case APP_IRQ_PRIORITY_LOW:
;;;1054               ret = APP_LOW_USER_ID;
;;;1055               break;
;;;1056               
;;;1057           default:
;;;1058               ret = THREAD_MODE_USER_ID;
00038a  2002              MOVS     r0,#2
;;;1059               break;
;;;1060       }
;;;1061       
;;;1062       return ret;
;;;1063   }
00038c  4770              BX       lr
                  |L1.910|
00038e  2000              MOVS     r0,#0                 ;1050
000390  4770              BX       lr
                  |L1.914|
000392  2001              MOVS     r0,#1                 ;1054
000394  4770              BX       lr
;;;1064   
                          ENDP

                  app_timer_start PROC
;;;1065   
;;;1066   uint32_t app_timer_start(app_timer_id_t timer_id, uint32_t timeout_ticks, void * p_context)
000396  b5fe              PUSH     {r1-r7,lr}
;;;1067   {
000398  4604              MOV      r4,r0
;;;1068       uint32_t timeout_periodic;
;;;1069       
;;;1070       // Check state and parameters
;;;1071       if (mp_nodes == NULL)
00039a  481d              LDR      r0,|L1.1040|
00039c  4617              MOV      r7,r2                 ;1067
00039e  6842              LDR      r2,[r0,#4]  ; mp_nodes
0003a0  460d              MOV      r5,r1                 ;1067
0003a2  2a00              CMP      r2,#0
0003a4  d00c              BEQ      |L1.960|
;;;1072       {
;;;1073           return NRF_ERROR_INVALID_STATE;
;;;1074       }
;;;1075       if ((timer_id >= m_node_array_size) || (timeout_ticks < APP_TIMER_MIN_TIMEOUT_TICKS))
0003a6  7801              LDRB     r1,[r0,#0]  ; m_node_array_size
0003a8  428c              CMP      r4,r1
0003aa  d201              BCS      |L1.944|
0003ac  2d05              CMP      r5,#5
0003ae  d201              BCS      |L1.948|
                  |L1.944|
;;;1076       {
;;;1077           return NRF_ERROR_INVALID_PARAM;
0003b0  2007              MOVS     r0,#7
;;;1078       }
;;;1079       if (mp_nodes[timer_id].state != STATE_ALLOCATED)
;;;1080       {
;;;1081           return NRF_ERROR_INVALID_STATE;
;;;1082       }
;;;1083       
;;;1084       // Schedule timer start operation
;;;1085       timeout_periodic = (mp_nodes[timer_id].mode == APP_TIMER_MODE_REPEATED) ? timeout_ticks : 0;
;;;1086   
;;;1087       return timer_start_op_schedule(user_id_get(),
;;;1088                                      timer_id,
;;;1089                                      timeout_ticks,
;;;1090                                      timeout_periodic,
;;;1091                                      p_context);
;;;1092   }
0003b2  bdfe              POP      {r1-r7,pc}
                  |L1.948|
0003b4  4621              MOV      r1,r4                 ;1079
0003b6  2324              MOVS     r3,#0x24              ;1079
0003b8  4359              MULS     r1,r3,r1              ;1079
0003ba  5c53              LDRB     r3,[r2,r1]            ;1079
0003bc  2b01              CMP      r3,#1                 ;1079
0003be  d001              BEQ      |L1.964|
                  |L1.960|
0003c0  2008              MOVS     r0,#8                 ;1081
0003c2  bdfe              POP      {r1-r7,pc}
                  |L1.964|
0003c4  1888              ADDS     r0,r1,r2              ;1085
0003c6  7840              LDRB     r0,[r0,#1]            ;1085
0003c8  2801              CMP      r0,#1                 ;1085
0003ca  d03f              BEQ      |L1.1100|
0003cc  2600              MOVS     r6,#0                 ;1085
                  |L1.974|
0003ce  f7fffffe          BL       user_id_get
0003d2  00c0              LSLS     r0,r0,#3              ;1087
0003d4  490e              LDR      r1,|L1.1040|
0003d6  9001              STR      r0,[sp,#4]            ;1087
0003d8  68c9              LDR      r1,[r1,#0xc]          ;1087  ; mp_users
0003da  1840              ADDS     r0,r0,r1              ;1087
0003dc  4669              MOV      r1,sp                 ;1087
0003de  f7fffffe          BL       user_op_alloc
0003e2  2800              CMP      r0,#0                 ;1087
0003e4  d034              BEQ      |L1.1104|
0003e6  2101              MOVS     r1,#1                 ;1087
0003e8  7001              STRB     r1,[r0,#0]            ;1087
0003ea  490a              LDR      r1,|L1.1044|
0003ec  6044              STR      r4,[r0,#4]            ;1087
0003ee  6849              LDR      r1,[r1,#4]            ;1087
0003f0  3008              ADDS     r0,r0,#8              ;1087
0003f2  c0e2              STM      r0!,{r1,r5-r7}        ;1087
0003f4  4906              LDR      r1,|L1.1040|
0003f6  9801              LDR      r0,[sp,#4]            ;1087
0003f8  68c9              LDR      r1,[r1,#0xc]          ;1087  ; mp_users
0003fa  1841              ADDS     r1,r0,r1              ;1087
0003fc  9800              LDR      r0,[sp,#0]            ;1087
0003fe  7048              STRB     r0,[r1,#1]            ;1087
000400  f7fffffe          BL       timer_list_handler_sched
000404  2000              MOVS     r0,#0                 ;1087
000406  bdfe              POP      {r1-r7,pc}
                  |L1.1032|
                          DCD      0xe000ed00
                  |L1.1036|
                          DCD      0xe000e400
                  |L1.1040|
                          DCD      ||.data||
                  |L1.1044|
                          DCD      0x40011500
                  |L1.1048|
000418  2e2e5c53          DCB      "..\\Source\\app_common\\app_timer.c",0
00041c  6f757263
000420  655c6170
000424  705f636f
000428  6d6d6f6e
00042c  5c617070
000430  5f74696d
000434  65722e63
000438  00      
000439  00                DCB      0
00043a  00                DCB      0
00043b  00                DCB      0
                  |L1.1084|
                          DCD      0x007fffff
                  |L1.1088|
                          DCD      0x40011140
                  |L1.1092|
                          DCD      0xe000e280
                  |L1.1096|
                          DCD      0xe000e100
                  |L1.1100|
00044c  462e              MOV      r6,r5                 ;1085
00044e  e7be              B        |L1.974|
                  |L1.1104|
000450  2004              MOVS     r0,#4                 ;1085
000452  bdfe              POP      {r1-r7,pc}
;;;1093   
                          ENDP

                  app_timer_stop PROC
;;;1094   
;;;1095   uint32_t app_timer_stop(app_timer_id_t timer_id)
000454  b5f8              PUSH     {r3-r7,lr}
;;;1096   {
;;;1097       // Check state and parameters
;;;1098       if (mp_nodes == NULL)
000456  4da7              LDR      r5,|L1.1780|
000458  4604              MOV      r4,r0                 ;1096
00045a  6868              LDR      r0,[r5,#4]  ; mp_nodes
00045c  2800              CMP      r0,#0
00045e  d009              BEQ      |L1.1140|
;;;1099       {
;;;1100           return NRF_ERROR_INVALID_STATE;
;;;1101       }
;;;1102       if (timer_id >= m_node_array_size)
000460  7829              LDRB     r1,[r5,#0]  ; m_node_array_size
000462  428c              CMP      r4,r1
000464  d301              BCC      |L1.1130|
;;;1103       {
;;;1104           return NRF_ERROR_INVALID_PARAM;
000466  2007              MOVS     r0,#7
;;;1105       }
;;;1106       if (mp_nodes[timer_id].state != STATE_ALLOCATED)
;;;1107       {
;;;1108           return NRF_ERROR_INVALID_STATE;
;;;1109       }
;;;1110       
;;;1111       // Schedule timer stop operation
;;;1112       return timer_stop_op_schedule(user_id_get(), timer_id);
;;;1113   }
000468  bdf8              POP      {r3-r7,pc}
                  |L1.1130|
00046a  2124              MOVS     r1,#0x24              ;1106
00046c  4361              MULS     r1,r4,r1              ;1106
00046e  5c40              LDRB     r0,[r0,r1]            ;1106
000470  2801              CMP      r0,#1                 ;1106
000472  d001              BEQ      |L1.1144|
                  |L1.1140|
000474  2008              MOVS     r0,#8                 ;1108
000476  bdf8              POP      {r3-r7,pc}
                  |L1.1144|
000478  f7fffffe          BL       user_id_get
00047c  00c6              LSLS     r6,r0,#3              ;1112
00047e  68e8              LDR      r0,[r5,#0xc]          ;1112  ; mp_users
000480  4669              MOV      r1,sp                 ;1112
000482  1830              ADDS     r0,r6,r0              ;1112
000484  f7fffffe          BL       user_op_alloc
000488  2800              CMP      r0,#0                 ;1112
00048a  d00a              BEQ      |L1.1186|
00048c  2102              MOVS     r1,#2                 ;1112
00048e  7001              STRB     r1,[r0,#0]            ;1112
000490  6044              STR      r4,[r0,#4]            ;1112
000492  68e8              LDR      r0,[r5,#0xc]          ;1112  ; mp_users
000494  1831              ADDS     r1,r6,r0              ;1112
000496  9800              LDR      r0,[sp,#0]            ;1112
000498  7048              STRB     r0,[r1,#1]            ;1112
00049a  f7fffffe          BL       timer_list_handler_sched
00049e  2000              MOVS     r0,#0                 ;1112
0004a0  bdf8              POP      {r3-r7,pc}
                  |L1.1186|
0004a2  2004              MOVS     r0,#4
0004a4  bdf8              POP      {r3-r7,pc}
;;;1114   
                          ENDP

                  rtc1_stop PROC
;;;171     */
;;;172    static void rtc1_stop(void)
0004a6  b510              PUSH     {r4,lr}
0004a8  2101              MOVS     r1,#1
0004aa  4a93              LDR      r2,|L1.1784|
0004ac  0448              LSLS     r0,r1,#17
0004ae  6010              STR      r0,[r2,#0]
;;;173    {
;;;174        NVIC_DisableIRQ(RTC1_IRQn);
;;;175    
;;;176        NRF_RTC1->EVTENCLR = RTC_EVTEN_COMPARE0_Msk;
0004b0  4a92              LDR      r2,|L1.1788|
0004b2  1040              ASRS     r0,r0,#1
0004b4  6090              STR      r0,[r2,#8]
;;;177        NRF_RTC1->INTENCLR = RTC_INTENSET_COMPARE0_Msk;
0004b6  4a91              LDR      r2,|L1.1788|
0004b8  3a40              SUBS     r2,r2,#0x40
0004ba  6090              STR      r0,[r2,#8]
;;;178    
;;;179        NRF_RTC1->TASKS_STOP = 1;
0004bc  4890              LDR      r0,|L1.1792|
0004be  6041              STR      r1,[r0,#4]
;;;180        nrf_delay_us(MAX_RTC_TASKS_DELAY);
0004c0  202f              MOVS     r0,#0x2f
0004c2  f7fffffe          BL       __asm___11_app_timer_c_cd27f9c3__nrf_delay_us
;;;181    }
0004c6  bd10              POP      {r4,pc}
;;;182    
                          ENDP

                  timer_list_handler_sched PROC
;;;326     */
;;;327    static void timer_list_handler_sched(void)
0004c8  2001              MOVS     r0,#1
0004ca  498b              LDR      r1,|L1.1784|
0004cc  0500              LSLS     r0,r0,#20
0004ce  3180              ADDS     r1,r1,#0x80
0004d0  6008              STR      r0,[r1,#0]
;;;328    {
;;;329        NVIC_SetPendingIRQ(SWI0_IRQn);
;;;330    }
0004d2  4770              BX       lr
;;;331    
                          ENDP

                  elapsed_ticks_acquire PROC
;;;426     */
;;;427    static bool elapsed_ticks_acquire(uint32_t * p_ticks_elapsed)
0004d4  b510              PUSH     {r4,lr}
;;;428    {
;;;429        // Pick the elapsed value from queue 
;;;430        if (m_ticks_elapsed_q_read_ind != m_ticks_elapsed_q_write_ind)
0004d6  4987              LDR      r1,|L1.1780|
0004d8  2300              MOVS     r3,#0
0004da  788a              LDRB     r2,[r1,#2]  ; m_ticks_elapsed_q_read_ind
0004dc  78cc              LDRB     r4,[r1,#3]  ; m_ticks_elapsed_q_write_ind
0004de  42a2              CMP      r2,r4
0004e0  d012              BEQ      |L1.1288|
0004e2  1c52              ADDS     r2,r2,#1              ;428
;;;431        {
;;;432            // Dequeue elapsed value 
;;;433            m_ticks_elapsed_q_read_ind++;
0004e4  b2d2              UXTB     r2,r2
0004e6  708a              STRB     r2,[r1,#2]
;;;434            if (m_ticks_elapsed_q_read_ind == CONTEXT_QUEUE_SIZE_MAX)
0004e8  2a02              CMP      r2,#2
0004ea  d100              BNE      |L1.1262|
;;;435            {
;;;436                m_ticks_elapsed_q_read_ind = 0;
0004ec  708b              STRB     r3,[r1,#2]
                  |L1.1262|
;;;437            }
;;;438    
;;;439            *p_ticks_elapsed = m_ticks_elapsed[m_ticks_elapsed_q_read_ind];
0004ee  788a              LDRB     r2,[r1,#2]  ; m_ticks_elapsed_q_read_ind
0004f0  4b80              LDR      r3,|L1.1780|
0004f2  0092              LSLS     r2,r2,#2
0004f4  331c              ADDS     r3,r3,#0x1c
0004f6  589a              LDR      r2,[r3,r2]
;;;440    
;;;441            m_ticks_latest += *p_ticks_elapsed;
0004f8  6002              STR      r2,[r0,#0]
0004fa  6948              LDR      r0,[r1,#0x14]  ; m_ticks_latest
0004fc  1810              ADDS     r0,r2,r0
;;;442            m_ticks_latest &= MAX_RTC_COUNTER_VAL;
0004fe  0200              LSLS     r0,r0,#8
000500  0a00              LSRS     r0,r0,#8
;;;443    
;;;444            return true;
000502  6148              STR      r0,[r1,#0x14]  ; m_ticks_latest
000504  2001              MOVS     r0,#1
;;;445        }
;;;446        else
;;;447        {
;;;448            // No elapsed value in queue 
;;;449            *p_ticks_elapsed = 0;
;;;450            return false;
;;;451        }
;;;452    }
000506  bd10              POP      {r4,pc}
                  |L1.1288|
000508  6003              STR      r3,[r0,#0]            ;450
00050a  2000              MOVS     r0,#0                 ;450
00050c  bd10              POP      {r4,pc}
;;;453    
                          ENDP

                  list_deletions_handler PROC
;;;458     */
;;;459    static bool list_deletions_handler(void)
00050e  b5f8              PUSH     {r3-r7,lr}
;;;460    {
;;;461        app_timer_id_t timer_id_old_head;
;;;462        uint8_t        user_id;
;;;463    
;;;464        // Remember the old head, so as to decide if new compare needs to be set
;;;465        timer_id_old_head = m_timer_id_head;
000510  4878              LDR      r0,|L1.1780|
000512  6901              LDR      r1,[r0,#0x10]  ; m_timer_id_head
;;;466    
;;;467        user_id = m_user_array_size;
000514  9100              STR      r1,[sp,#0]
000516  7845              LDRB     r5,[r0,#1]  ; m_user_array_size
000518  e033              B        |L1.1410|
                  |L1.1306|
;;;468        while (user_id--)
;;;469        {
;;;470            timer_user_t * p_user         = &mp_users[user_id];
00051a  4876              LDR      r0,|L1.1780|
00051c  00e9              LSLS     r1,r5,#3              ;460
00051e  68c0              LDR      r0,[r0,#0xc]  ; mp_users
000520  180e              ADDS     r6,r1,r0
;;;471            uint8_t        user_ops_first = p_user->first;
000522  7834              LDRB     r4,[r6,#0]
;;;472            
;;;473            while (user_ops_first != p_user->last)
000524  e02a              B        |L1.1404|
                  |L1.1318|
;;;474            {
;;;475                timer_node_t *    p_timer;
;;;476                timer_user_op_t * p_user_op = &p_user->p_user_op_queue[user_ops_first];
000526  2018              MOVS     r0,#0x18
000528  4360              MULS     r0,r4,r0
00052a  6871              LDR      r1,[r6,#4]
00052c  1c64              ADDS     r4,r4,#1
00052e  1808              ADDS     r0,r1,r0
;;;477    
;;;478                // Traverse to next operation in queue 
;;;479                user_ops_first++;
;;;480                if (user_ops_first == p_user->user_op_queue_size)
000530  78b1              LDRB     r1,[r6,#2]
000532  b2e4              UXTB     r4,r4                 ;479
000534  42a1              CMP      r1,r4
000536  d100              BNE      |L1.1338|
;;;481                {
;;;482                    user_ops_first = 0;
000538  2400              MOVS     r4,#0
                  |L1.1338|
;;;483                }
;;;484    
;;;485                switch (p_user_op->op_type)
00053a  7801              LDRB     r1,[r0,#0]
00053c  2902              CMP      r1,#2
00053e  d002              BEQ      |L1.1350|
000540  2903              CMP      r1,#3
000542  d11b              BNE      |L1.1404|
000544  e013              B        |L1.1390|
                  |L1.1350|
;;;486                {
;;;487                    case TIMER_USER_OP_TYPE_STOP:
;;;488                        // Delete node if timer is running
;;;489                        p_timer = &mp_nodes[p_user_op->timer_id];
000546  4a6b              LDR      r2,|L1.1780|
000548  6840              LDR      r0,[r0,#4]
00054a  2124              MOVS     r1,#0x24
00054c  6852              LDR      r2,[r2,#4]  ; mp_nodes
00054e  4341              MULS     r1,r0,r1
000550  188f              ADDS     r7,r1,r2
;;;490                        if (p_timer->is_running)
000552  7d39              LDRB     r1,[r7,#0x14]
000554  2900              CMP      r1,#0
000556  d011              BEQ      |L1.1404|
;;;491                        {
;;;492                            timer_list_remove(p_user_op->timer_id);
000558  f7fffffe          BL       timer_list_remove
;;;493                            p_timer->is_running = false;
00055c  2000              MOVS     r0,#0
00055e  7538              STRB     r0,[r7,#0x14]
000560  e00c              B        |L1.1404|
                  |L1.1378|
;;;494                        }
;;;495                        break;
;;;496                        
;;;497                    case TIMER_USER_OP_TYPE_STOP_ALL:
;;;498                        // Delete list of running timers, and mark all timers as not running
;;;499                        while (m_timer_id_head != TIMER_NULL)
;;;500                        {
;;;501                            timer_node_t * p_head = &mp_nodes[m_timer_id_head];
000562  2724              MOVS     r7,#0x24
000564  4378              MULS     r0,r7,r0
000566  18c0              ADDS     r0,r0,r3
;;;502    
;;;503                            p_head->is_running = false;
000568  7502              STRB     r2,[r0,#0x14]
;;;504                            m_timer_id_head    = p_head->next;
00056a  6a00              LDR      r0,[r0,#0x20]
;;;505                        }
00056c  e003              B        |L1.1398|
                  |L1.1390|
00056e  4961              LDR      r1,|L1.1780|
000570  2200              MOVS     r2,#0                 ;501
000572  684b              LDR      r3,[r1,#4]            ;501  ; mp_nodes
000574  6908              LDR      r0,[r1,#0x10]         ;501  ; m_timer_id_head
                  |L1.1398|
000576  1c47              ADDS     r7,r0,#1              ;499
000578  d1f3              BNE      |L1.1378|
00057a  6108              STR      r0,[r1,#0x10]         ;504  ; m_timer_id_head
                  |L1.1404|
00057c  7870              LDRB     r0,[r6,#1]            ;473
00057e  42a0              CMP      r0,r4                 ;473
000580  d1d1              BNE      |L1.1318|
                  |L1.1410|
000582  4628              MOV      r0,r5                 ;468
000584  1e6d              SUBS     r5,r5,#1              ;468
000586  b2ed              UXTB     r5,r5                 ;468
000588  2800              CMP      r0,#0                 ;468
00058a  d1c6              BNE      |L1.1306|
;;;506                        break;
;;;507                        
;;;508                    default:
;;;509                        // No implementation needed.
;;;510                        break;
;;;511                }
;;;512            }
;;;513        }
;;;514    
;;;515        // Detect change in head of the list
;;;516        return (m_timer_id_head != timer_id_old_head);
00058c  4859              LDR      r0,|L1.1780|
00058e  6901              LDR      r1,[r0,#0x10]  ; m_timer_id_head
000590  9800              LDR      r0,[sp,#0]
000592  4281              CMP      r1,r0
000594  d001              BEQ      |L1.1434|
000596  2001              MOVS     r0,#1
;;;517    }
000598  bdf8              POP      {r3-r7,pc}
                  |L1.1434|
00059a  2000              MOVS     r0,#0                 ;516
00059c  bdf8              POP      {r3-r7,pc}
;;;518    
                          ENDP

                  expired_timers_handler PROC
;;;525     */
;;;526    static void expired_timers_handler(uint32_t         ticks_elapsed,
00059e  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;527                                       uint32_t         ticks_previous,
;;;528                                       app_timer_id_t * p_restart_list_head)
;;;529    {
;;;530        uint32_t ticks_expired = 0;
;;;531    
;;;532        while (m_timer_id_head != TIMER_NULL)
;;;533        {
;;;534            timer_node_t * p_timer;
;;;535            app_timer_id_t id_expired;
;;;536    
;;;537            // Auto variable for current timer node 
;;;538            p_timer = &mp_nodes[m_timer_id_head];
0005a0  4c54              LDR      r4,|L1.1780|
0005a2  2500              MOVS     r5,#0                 ;530
0005a4  6867              LDR      r7,[r4,#4]            ;529  ; mp_nodes
0005a6  6923              LDR      r3,[r4,#0x10]         ;529  ; m_timer_id_head
0005a8  e01e              B        |L1.1512|
                  |L1.1450|
0005aa  2124              MOVS     r1,#0x24
0005ac  4359              MULS     r1,r3,r1
0005ae  19c9              ADDS     r1,r1,r7
;;;539    
;;;540            // Do nothing if timer did not expire 
;;;541            if (ticks_elapsed < p_timer->ticks_to_expire)
0005b0  684e              LDR      r6,[r1,#4]
0005b2  4286              CMP      r6,r0
0005b4  d902              BLS      |L1.1468|
;;;542            {
;;;543                p_timer->ticks_to_expire -= ticks_elapsed;
0005b6  1a30              SUBS     r0,r6,r0
;;;544                break;
0005b8  6048              STR      r0,[r1,#4]
0005ba  e017              B        |L1.1516|
                  |L1.1468|
;;;545            }
;;;546    
;;;547            // Decrement ticks_elapsed and collect expired ticks 
;;;548            ticks_elapsed -= p_timer->ticks_to_expire;
0005bc  1b80              SUBS     r0,r0,r6
;;;549            ticks_expired += p_timer->ticks_to_expire;
0005be  1975              ADDS     r5,r6,r5
;;;550    
;;;551            // Timer expired, set ticks_to_expire zero
;;;552            p_timer->ticks_to_expire = 0;
0005c0  2600              MOVS     r6,#0
;;;553            p_timer->is_running      = false;
0005c2  604e              STR      r6,[r1,#4]
0005c4  750e              STRB     r6,[r1,#0x14]
;;;554    
;;;555            // Remove the expired timer from head 
;;;556            id_expired      = m_timer_id_head;
;;;557            m_timer_id_head = p_timer->next;
;;;558    
;;;559            // Timer will be restarted if periodic 
;;;560            if (p_timer->ticks_periodic_interval != 0)
0005c6  690e              LDR      r6,[r1,#0x10]
0005c8  469c              MOV      r12,r3                ;556
0005ca  6a0b              LDR      r3,[r1,#0x20]
0005cc  46b6              MOV      lr,r6
0005ce  2e00              CMP      r6,#0
0005d0  d00a              BEQ      |L1.1512|
;;;561            {
;;;562                p_timer->ticks_at_start       = (ticks_previous + ticks_expired) & MAX_RTC_COUNTER_VAL;
0005d2  9e01              LDR      r6,[sp,#4]
0005d4  1976              ADDS     r6,r6,r5
0005d6  0236              LSLS     r6,r6,#8
0005d8  0a36              LSRS     r6,r6,#8
0005da  608e              STR      r6,[r1,#8]
0005dc  4676              MOV      r6,lr
;;;563                p_timer->ticks_first_interval = p_timer->ticks_periodic_interval;
;;;564                p_timer->next                 = *p_restart_list_head;
0005de  60ce              STR      r6,[r1,#0xc]
0005e0  6816              LDR      r6,[r2,#0]
;;;565                *p_restart_list_head          = id_expired;
0005e2  620e              STR      r6,[r1,#0x20]
0005e4  4661              MOV      r1,r12
0005e6  6011              STR      r1,[r2,#0]
                  |L1.1512|
0005e8  1c59              ADDS     r1,r3,#1              ;532
0005ea  d1de              BNE      |L1.1450|
                  |L1.1516|
0005ec  6123              STR      r3,[r4,#0x10]         ;557  ; m_timer_id_head
;;;566            }
;;;567        }
;;;568    }
0005ee  bdfe              POP      {r1-r7,pc}
;;;569    
                          ENDP

                  compare_reg_update PROC
;;;666     */
;;;667    static void compare_reg_update(app_timer_id_t timer_id_head_old)
0005f0  b5f8              PUSH     {r3-r7,lr}
;;;668    {
;;;669        // Setup the timeout for timers on the head of the list 
;;;670        if (m_timer_id_head != TIMER_NULL)
0005f2  4940              LDR      r1,|L1.1780|
0005f4  690a              LDR      r2,[r1,#0x10]  ; m_timer_id_head
0005f6  1c53              ADDS     r3,r2,#1
0005f8  d03a              BEQ      |L1.1648|
;;;671        {
;;;672            uint32_t ticks_to_expire = mp_nodes[m_timer_id_head].ticks_to_expire;
0005fa  2324              MOVS     r3,#0x24
0005fc  435a              MULS     r2,r3,r2
0005fe  684b              LDR      r3,[r1,#4]  ; mp_nodes
000600  18d2              ADDS     r2,r2,r3
000602  6856              LDR      r6,[r2,#4]
000604  4a3f              LDR      r2,|L1.1796|
000606  6854              LDR      r4,[r2,#4]
;;;673            uint32_t pre_counter_val = rtc1_counter_get();
;;;674            uint32_t cc              = m_ticks_latest;
;;;675            uint32_t ticks_elapsed   = ticks_diff_get(pre_counter_val, cc) + RTC_COMPARE_OFFSET_MIN;
000608  694f              LDR      r7,[r1,#0x14]  ; m_ticks_latest
00060a  1c40              ADDS     r0,r0,#1
00060c  1be1              SUBS     r1,r4,r7
00060e  020d              LSLS     r5,r1,#8
000610  0a2d              LSRS     r5,r5,#8
000612  2101              MOVS     r1,#1
000614  1ced              ADDS     r5,r5,#3
;;;676    
;;;677            if (timer_id_head_old == TIMER_NULL)
000616  2800              CMP      r0,#0
000618  d110              BNE      |L1.1596|
00061a  4a38              LDR      r2,|L1.1788|
00061c  0408              LSLS     r0,r1,#16
00061e  6050              STR      r0,[r2,#4]
000620  4a36              LDR      r2,|L1.1788|
000622  3a40              SUBS     r2,r2,#0x40
000624  6050              STR      r0,[r2,#4]
000626  4a38              LDR      r2,|L1.1800|
000628  0040              LSLS     r0,r0,#1
00062a  6010              STR      r0,[r2,#0]
00062c  4a32              LDR      r2,|L1.1784|
00062e  3a80              SUBS     r2,r2,#0x80
000630  6010              STR      r0,[r2,#0]
000632  4833              LDR      r0,|L1.1792|
000634  6001              STR      r1,[r0,#0]
000636  202f              MOVS     r0,#0x2f
000638  f7fffffe          BL       __asm___11_app_timer_c_cd27f9c3__nrf_delay_us
                  |L1.1596|
;;;678            {
;;;679                // No timers were already running, start RTC
;;;680                rtc1_start();
;;;681            }
;;;682    
;;;683            cc += (ticks_elapsed < ticks_to_expire) ? ticks_to_expire : ticks_elapsed;
00063c  42b5              CMP      r5,r6
00063e  d200              BCS      |L1.1602|
000640  4635              MOV      r5,r6
                  |L1.1602|
000642  19e8              ADDS     r0,r5,r7
;;;684            cc &= MAX_RTC_COUNTER_VAL;
000644  0200              LSLS     r0,r0,#8
000646  492f              LDR      r1,|L1.1796|
000648  0a00              LSRS     r0,r0,#8
00064a  3140              ADDS     r1,r1,#0x40
00064c  6008              STR      r0,[r1,#0]
00064e  492d              LDR      r1,|L1.1796|
000650  6849              LDR      r1,[r1,#4]
000652  1b00              SUBS     r0,r0,r4
000654  1b09              SUBS     r1,r1,r4
000656  0209              LSLS     r1,r1,#8
000658  0a09              LSRS     r1,r1,#8
00065a  0200              LSLS     r0,r0,#8
00065c  0a00              LSRS     r0,r0,#8
00065e  1cc9              ADDS     r1,r1,#3
;;;685            
;;;686            rtc1_compare0_set(cc);
;;;687    
;;;688            uint32_t post_counter_val = rtc1_counter_get();
;;;689    
;;;690            if (
000660  4281              CMP      r1,r0
000662  d904              BLS      |L1.1646|
000664  2001              MOVS     r0,#1
000666  4924              LDR      r1,|L1.1784|
000668  0440              LSLS     r0,r0,#17
00066a  3180              ADDS     r1,r1,#0x80
00066c  6008              STR      r0,[r1,#0]
                  |L1.1646|
;;;691                (ticks_diff_get(post_counter_val, pre_counter_val) + RTC_COMPARE_OFFSET_MIN)
;;;692                >
;;;693                ticks_diff_get(cc, pre_counter_val)
;;;694               )
;;;695            {
;;;696                // When this happens the COMPARE event may not be triggered by the RTC.
;;;697                // The nRF51 Series User Specification states that if the COUNTER value is N
;;;698                // (i.e post_counter_val = N), writing N or N+1 to a CC register may not trigger a
;;;699                // COMPARE event. Hence the RTC interrupt is forcefully pended by calling the following
;;;700                // function.
;;;701                timer_timeouts_check_sched();
;;;702            }
;;;703        }
;;;704        else
;;;705        {
;;;706            // No timers are running, stop RTC
;;;707            rtc1_stop();
;;;708        }
;;;709    }
00066e  bdf8              POP      {r3-r7,pc}
                  |L1.1648|
000670  f7fffffe          BL       rtc1_stop
000674  bdf8              POP      {r3-r7,pc}
;;;710    
                          ENDP

                  user_op_alloc PROC
;;;771     */
;;;772    static timer_user_op_t * user_op_alloc(timer_user_t * p_user, app_timer_id_t * p_last_index)
000676  7842              LDRB     r2,[r0,#1]
;;;773    {        
;;;774        app_timer_id_t    last;
;;;775        timer_user_op_t * p_user_op;
;;;776        
;;;777        last = p_user->last + 1;
;;;778        if (last == p_user->user_op_queue_size)
000678  7883              LDRB     r3,[r0,#2]
00067a  1c52              ADDS     r2,r2,#1
00067c  4293              CMP      r3,r2
00067e  d100              BNE      |L1.1666|
;;;779        {
;;;780            // Overflow case.
;;;781            last = 0;
000680  2200              MOVS     r2,#0
                  |L1.1666|
;;;782        }
;;;783        if (last == p_user->first)
000682  7803              LDRB     r3,[r0,#0]
000684  4293              CMP      r3,r2
000686  d101              BNE      |L1.1676|
;;;784        {
;;;785            // Queue is full.
;;;786            return NULL;
000688  2000              MOVS     r0,#0
;;;787        }
;;;788        
;;;789        *p_last_index = last;    
;;;790        p_user_op     = &p_user->p_user_op_queue[p_user->last];
;;;791            
;;;792        return p_user_op;
;;;793    }
00068a  4770              BX       lr
                  |L1.1676|
00068c  600a              STR      r2,[r1,#0]            ;790
00068e  6841              LDR      r1,[r0,#4]            ;790
000690  7840              LDRB     r0,[r0,#1]            ;790
000692  2218              MOVS     r2,#0x18              ;790
000694  4350              MULS     r0,r2,r0              ;790
000696  1808              ADDS     r0,r1,r0              ;790
000698  4770              BX       lr
;;;794    
                          ENDP

                  timer_list_remove PROC
;;;269     */
;;;270    static void timer_list_remove(app_timer_id_t timer_id)
00069a  b570              PUSH     {r4-r6,lr}
;;;271    {
;;;272        app_timer_id_t previous;
;;;273        app_timer_id_t current;
;;;274        uint32_t       timeout;
;;;275    
;;;276        // Find the timer's position in timer list
;;;277        previous = m_timer_id_head;
00069c  4d15              LDR      r5,|L1.1780|
00069e  692a              LDR      r2,[r5,#0x10]  ; m_timer_id_head
0006a0  686b              LDR      r3,[r5,#4]            ;271  ; mp_nodes
0006a2  4614              MOV      r4,r2
;;;278        current  = previous;
0006a4  4611              MOV      r1,r2
0006a6  e006              B        |L1.1718|
                  |L1.1704|
;;;279        
;;;280        while (current != TIMER_NULL)
;;;281        {
;;;282            if (current == timer_id)
0006a8  4281              CMP      r1,r0
0006aa  d007              BEQ      |L1.1724|
;;;283            {
;;;284                break;
;;;285            }
;;;286            previous = current;
0006ac  460a              MOV      r2,r1
;;;287            current  = mp_nodes[current].next;
0006ae  2624              MOVS     r6,#0x24
0006b0  4371              MULS     r1,r6,r1
0006b2  18c9              ADDS     r1,r1,r3
0006b4  6a09              LDR      r1,[r1,#0x20]
                  |L1.1718|
0006b6  1c4e              ADDS     r6,r1,#1              ;280
0006b8  d1f6              BNE      |L1.1704|
                  |L1.1722|
;;;288        }
;;;289    
;;;290        // Timer not in active list
;;;291        if (current == TIMER_NULL)
;;;292        {
;;;293            return;
;;;294        }
;;;295    
;;;296        // Timer is the first in the list
;;;297        if (previous == current)
;;;298        {
;;;299            m_timer_id_head = mp_nodes[m_timer_id_head].next;
;;;300        }
;;;301    
;;;302        // Remaining timeout between next timeout
;;;303        timeout = mp_nodes[current].ticks_to_expire;
;;;304    
;;;305        // Link previous timer with next of this timer, i.e. removing the timer from list
;;;306        mp_nodes[previous].next = mp_nodes[current].next;
;;;307    
;;;308        // If this is not the last timer, increment the next timer by this timer timeout
;;;309        current = mp_nodes[previous].next;
;;;310        if (current != TIMER_NULL)
;;;311        {
;;;312            mp_nodes[current].ticks_to_expire += timeout;
;;;313        }
;;;314    }
0006ba  bd70              POP      {r4-r6,pc}
                  |L1.1724|
0006bc  2e00              CMP      r6,#0                 ;291
0006be  d0fc              BEQ      |L1.1722|
0006c0  428a              CMP      r2,r1                 ;297
0006c2  d104              BNE      |L1.1742|
0006c4  2024              MOVS     r0,#0x24              ;299
0006c6  4344              MULS     r4,r0,r4              ;299
0006c8  18e0              ADDS     r0,r4,r3              ;299
0006ca  6a00              LDR      r0,[r0,#0x20]         ;299
0006cc  6128              STR      r0,[r5,#0x10]         ;299  ; m_timer_id_head
                  |L1.1742|
0006ce  2024              MOVS     r0,#0x24              ;303
0006d0  4341              MULS     r1,r0,r1              ;303
0006d2  18c8              ADDS     r0,r1,r3              ;303
0006d4  2424              MOVS     r4,#0x24              ;306
0006d6  6841              LDR      r1,[r0,#4]            ;306
0006d8  4362              MULS     r2,r4,r2              ;306
0006da  6a00              LDR      r0,[r0,#0x20]         ;306
0006dc  18d2              ADDS     r2,r2,r3              ;306
0006de  6210              STR      r0,[r2,#0x20]         ;310
0006e0  1c42              ADDS     r2,r0,#1              ;310
0006e2  d0ea              BEQ      |L1.1722|
0006e4  2224              MOVS     r2,#0x24              ;312
0006e6  4350              MULS     r0,r2,r0              ;312
0006e8  18c0              ADDS     r0,r0,r3              ;312
0006ea  6842              LDR      r2,[r0,#4]            ;312
0006ec  1851              ADDS     r1,r2,r1              ;312
0006ee  6041              STR      r1,[r0,#4]            ;312
0006f0  bd70              POP      {r4-r6,pc}
;;;315    
                          ENDP

0006f2  0000              DCW      0x0000
                  |L1.1780|
                          DCD      ||.data||
                  |L1.1784|
                          DCD      0xe000e180
                  |L1.1788|
                          DCD      0x40011340
                  |L1.1792|
                          DCD      0x40011000
                  |L1.1796|
                          DCD      0x40011500
                  |L1.1800|
                          DCD      0xe000e280

                          AREA ||area_number.2||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.2||, ||.text||
                  app_timer_stop_all PROC
;;;1115   
;;;1116   uint32_t app_timer_stop_all(void)
000000  b538              PUSH     {r3-r5,lr}
;;;1117   {
;;;1118       // Check state
;;;1119       if (mp_nodes == NULL)
000002  4c0f              LDR      r4,|L2.64|
000004  6860              LDR      r0,[r4,#4]  ; mp_nodes
000006  2800              CMP      r0,#0
000008  d015              BEQ      |L2.54|
;;;1120       {
;;;1121           return NRF_ERROR_INVALID_STATE;
;;;1122       }
;;;1123   
;;;1124       return timer_stop_all_op_schedule(user_id_get());
00000a  f7fffffe          BL       user_id_get
00000e  00c5              LSLS     r5,r0,#3
000010  68e0              LDR      r0,[r4,#0xc]  ; mp_users
000012  4669              MOV      r1,sp
000014  1828              ADDS     r0,r5,r0
000016  f7fffffe          BL       user_op_alloc
00001a  2800              CMP      r0,#0
00001c  d00d              BEQ      |L2.58|
00001e  2103              MOVS     r1,#3
000020  7001              STRB     r1,[r0,#0]
000022  1f09              SUBS     r1,r1,#4
000024  6041              STR      r1,[r0,#4]
000026  68e0              LDR      r0,[r4,#0xc]  ; mp_users
000028  1829              ADDS     r1,r5,r0
00002a  9800              LDR      r0,[sp,#0]
00002c  7048              STRB     r0,[r1,#1]
00002e  f7fffffe          BL       timer_list_handler_sched
000032  2000              MOVS     r0,#0
;;;1125   }
000034  bd38              POP      {r3-r5,pc}
                  |L2.54|
000036  2008              MOVS     r0,#8                 ;1121
000038  bd38              POP      {r3-r5,pc}
                  |L2.58|
00003a  2004              MOVS     r0,#4
00003c  bd38              POP      {r3-r5,pc}
;;;1126   
                          ENDP

00003e  0000              DCW      0x0000
                  |L2.64|
                          DCD      ||.data||

                          AREA ||area_number.3||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.3||, ||.text||
                  app_timer_cnt_get PROC
;;;1115   
;;;1116   uint32_t app_timer_stop_all(void)
000000  4902              LDR      r1,|L3.12|
;;;1117   {
;;;1118       // Check state
;;;1119       if (mp_nodes == NULL)
000002  6849              LDR      r1,[r1,#4]
000004  6001              STR      r1,[r0,#0]
000006  2000              MOVS     r0,#0
000008  4770              BX       lr                    ;1117
;;;1120       {
;;;1121           return NRF_ERROR_INVALID_STATE;
;;;1122       }
;;;1123   
;;;1124       return timer_stop_all_op_schedule(user_id_get());
;;;1125   }
;;;1126   
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      0x40011500

                          AREA ||area_number.4||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.4||, ||.text||
                  app_timer_cnt_diff_compute PROC
;;;1115   
;;;1116   uint32_t app_timer_stop_all(void)
000000  1a40              SUBS     r0,r0,r1
;;;1117   {
;;;1118       // Check state
;;;1119       if (mp_nodes == NULL)
000002  0200              LSLS     r0,r0,#8
000004  0a00              LSRS     r0,r0,#8
000006  6010              STR      r0,[r2,#0]
000008  2000              MOVS     r0,#0                 ;1117
;;;1120       {
;;;1121           return NRF_ERROR_INVALID_STATE;
;;;1122       }
;;;1123   
;;;1124       return timer_stop_all_op_schedule(user_id_get());
00000a  4770              BX       lr
;;;1125   }
;;;1126   
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  m_node_array_size
000000  00                DCB      0x00
                  m_user_array_size
000001  00                DCB      0x00
                  m_ticks_elapsed_q_read_ind
000002  00                DCB      0x00
                  m_ticks_elapsed_q_write_ind
000003  00                DCB      0x00
                  mp_nodes
                          DCD      0x00000000
                  count
                          DCD      0x00000000
                  mp_users
                          DCD      0x00000000
                  m_timer_id_head
                          DCD      0x00000000
                  m_ticks_latest
                          DCD      0x00000000
                  m_evt_schedule_func
                          DCD      0x00000000
                  m_ticks_elapsed
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\Source\\app_common\\app_timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_app_timer_c_cd27f9c3____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_app_timer_c_cd27f9c3____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_app_timer_c_cd27f9c3____REVSH|
#line 144
|__asm___11_app_timer_c_cd27f9c3____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_app_timer_c_cd27f9c3__nrf_delay_us|
#line 8 "..\\Include\\nrf_delay.h"
|__asm___11_app_timer_c_cd27f9c3__nrf_delay_us| PROC
#line 9

loop
 SUBS R0, R0, #1
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 BNE loop
 BX LR
	ENDP

;*** End   embedded assembler ***
