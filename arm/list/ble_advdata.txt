; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\ble_advdata.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\ble_advdata.d --feedback=.\obj\ak2_v1_1_0.fed --cpu=Cortex-M0 --apcs=interwork -O3 --diag_suppress=9931 -I..\Include -I..\user -I..\Include\app_common -I..\Include\ble -I..\Include\ble\ble_services -I..\Include\s110 -I..\Include\boards -I..\Include\sd_common -IC:\Johnson_project\2016_Project\BLE_Pedometer\Fittless_wearable\firmware_design\git-project\arm\RTE -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.6.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DNRF51 -DNRF51 -DDEBUG_NRF_USER -DSETUPA -DBOARD_AKII -DBLE_STACK_SUPPORT_REQD --omf_browse=.\obj\ble_advdata.crf ..\Source\ble\ble_advdata.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  uuid_list_sized_encode PROC
;;;172    
;;;173    static uint32_t uuid_list_sized_encode(const ble_advdata_uuid_list_t * p_uuid_list,
000000  b5ff              PUSH     {r0-r7,lr}
;;;174                                           uint8_t                         adv_type,
;;;175                                           uint8_t                         uuid_size,
;;;176                                           uint8_t *                       p_encoded_data,
;;;177                                           uint8_t *                       p_len)
;;;178    {
000002  b083              SUB      sp,sp,#0xc
000004  4607              MOV      r7,r0
;;;179        int     i;
;;;180        bool    is_heading_written = false;
000006  2000              MOVS     r0,#0
;;;181        uint8_t start_pos = *p_len;
000008  9c0c              LDR      r4,[sp,#0x30]
00000a  4686              MOV      lr,r0                 ;180
00000c  7826              LDRB     r6,[r4,#0]
;;;182        
;;;183        for (i = 0; i < p_uuid_list->uuid_cnt; i++)
00000e  4605              MOV      r5,r0
000010  e03a              B        |L1.136|
                  |L1.18|
;;;184        {
;;;185            uint32_t   err_code;
;;;186            uint8_t    encoded_size;
;;;187            ble_uuid_t uuid = p_uuid_list->p_uuids[i];
000012  6878              LDR      r0,[r7,#4]
000014  00a9              LSLS     r1,r5,#2
000016  1841              ADDS     r1,r0,r1
000018  880a              LDRH     r2,[r1,#0]
00001a  4668              MOV      r0,sp
00001c  8082              STRH     r2,[r0,#4]
00001e  8849              LDRH     r1,[r1,#2]
000020  80c1              STRH     r1,[r0,#6]
;;;188            
;;;189            // Find encoded uuid size.
;;;190            err_code = sd_ble_uuid_encode(&uuid, &encoded_size, NULL);
000022  2200              MOVS     r2,#0
000024  4669              MOV      r1,sp
000026  a801              ADD      r0,sp,#4
000028  df64              SVC      #0x64
;;;191            if (err_code != NRF_SUCCESS)
00002a  2800              CMP      r0,#0
00002c  d110              BNE      |L1.80|
;;;192            {
;;;193                return err_code;
;;;194            }
;;;195            
;;;196            // Check size.
;;;197            if (encoded_size == uuid_size)
00002e  4668              MOV      r0,sp
000030  7801              LDRB     r1,[r0,#0]
000032  9805              LDR      r0,[sp,#0x14]
000034  4281              CMP      r1,r0
000036  d126              BNE      |L1.134|
;;;198            {
;;;199                uint8_t heading_bytes = (is_heading_written) ? 0 : 2;
000038  4670              MOV      r0,lr
00003a  2800              CMP      r0,#0
00003c  d001              BEQ      |L1.66|
00003e  2200              MOVS     r2,#0
000040  e000              B        |L1.68|
                  |L1.66|
000042  2202              MOVS     r2,#2
                  |L1.68|
;;;200                
;;;201                // Check for buffer overflow
;;;202                if (*p_len + encoded_size + heading_bytes > BLE_GAP_ADV_MAX_SIZE)
000044  7820              LDRB     r0,[r4,#0]
000046  1889              ADDS     r1,r1,r2
000048  1841              ADDS     r1,r0,r1
00004a  291f              CMP      r1,#0x1f
00004c  d902              BLS      |L1.84|
;;;203                {
;;;204                    return NRF_ERROR_DATA_SIZE;
00004e  200c              MOVS     r0,#0xc
                  |L1.80|
;;;205                }
;;;206                
;;;207                if (!is_heading_written)
;;;208                {
;;;209                    // Write AD structure heading.
;;;210                    (*p_len)++;
;;;211                    p_encoded_data[(*p_len)++] = adv_type;
;;;212                    is_heading_written = true;
;;;213                }
;;;214                
;;;215                // Write UUID.
;;;216                err_code = sd_ble_uuid_encode(&uuid, &encoded_size, &p_encoded_data[*p_len]);
;;;217                if (err_code != NRF_SUCCESS)
;;;218                {
;;;219                    return err_code;
;;;220                }
;;;221                (*p_len) += encoded_size;
;;;222            }
;;;223        }
;;;224        
;;;225        if (is_heading_written)
;;;226        {
;;;227            // Write length.
;;;228            p_encoded_data[start_pos] = (*p_len) - (start_pos + 1);
;;;229        }
;;;230        
;;;231        return NRF_SUCCESS;
;;;232    }
000050  b007              ADD      sp,sp,#0x1c
000052  bdf0              POP      {r4-r7,pc}
                  |L1.84|
000054  4671              MOV      r1,lr                 ;207
000056  2900              CMP      r1,#0                 ;207
000058  d108              BNE      |L1.108|
00005a  1c40              ADDS     r0,r0,#1              ;207
00005c  b2c0              UXTB     r0,r0                 ;210
00005e  1c41              ADDS     r1,r0,#1              ;211
000060  9b06              LDR      r3,[sp,#0x18]         ;211
000062  9a04              LDR      r2,[sp,#0x10]         ;211
000064  7021              STRB     r1,[r4,#0]            ;211
000066  541a              STRB     r2,[r3,r0]            ;211
000068  2001              MOVS     r0,#1                 ;212
00006a  4686              MOV      lr,r0                 ;212
                  |L1.108|
00006c  7821              LDRB     r1,[r4,#0]            ;216
00006e  9806              LDR      r0,[sp,#0x18]         ;216
000070  180a              ADDS     r2,r1,r0              ;216
000072  4669              MOV      r1,sp                 ;216
000074  a801              ADD      r0,sp,#4              ;216
000076  df64              SVC      #0x64                 ;216
000078  2800              CMP      r0,#0                 ;217
00007a  d1e9              BNE      |L1.80|
00007c  4669              MOV      r1,sp                 ;221
00007e  7820              LDRB     r0,[r4,#0]            ;221
000080  7809              LDRB     r1,[r1,#0]            ;221
000082  1840              ADDS     r0,r0,r1              ;221
000084  7020              STRB     r0,[r4,#0]            ;221
                  |L1.134|
000086  1c6d              ADDS     r5,r5,#1              ;221
                  |L1.136|
000088  8838              LDRH     r0,[r7,#0]            ;183
00008a  42a8              CMP      r0,r5                 ;183
00008c  dcc1              BGT      |L1.18|
00008e  4670              MOV      r0,lr                 ;225
000090  2800              CMP      r0,#0                 ;225
000092  d004              BEQ      |L1.158|
000094  7820              LDRB     r0,[r4,#0]            ;228
000096  9906              LDR      r1,[sp,#0x18]         ;228
000098  1b80              SUBS     r0,r0,r6              ;228
00009a  1e40              SUBS     r0,r0,#1              ;228
00009c  5588              STRB     r0,[r1,r6]            ;228
                  |L1.158|
00009e  2000              MOVS     r0,#0                 ;231
0000a0  e7d6              B        |L1.80|
;;;233    
                          ENDP

                  uuid_list_encode PROC
;;;234    
;;;235    static uint32_t uuid_list_encode(const ble_advdata_uuid_list_t * p_uuid_list,
0000a2  b5f8              PUSH     {r3-r7,lr}
;;;236                                     uint8_t                         adv_type_16,
;;;237                                     uint8_t                         adv_type_128,
;;;238                                     uint8_t *                       p_encoded_data,
;;;239                                     uint8_t *                       p_len)
;;;240    {
0000a4  4615              MOV      r5,r2
;;;241        uint32_t err_code;
;;;242        
;;;243        // Encode 16 bit UUIDs.
;;;244        err_code = uuid_list_sized_encode(p_uuid_list,
0000a6  9c06              LDR      r4,[sp,#0x18]
0000a8  461e              MOV      r6,r3                 ;240
0000aa  4607              MOV      r7,r0                 ;240
0000ac  2202              MOVS     r2,#2
0000ae  9400              STR      r4,[sp,#0]
0000b0  f7fffffe          BL       uuid_list_sized_encode
;;;245                                          adv_type_16,
;;;246                                          sizeof(uint16_le_t),
;;;247                                          p_encoded_data,
;;;248                                          p_len);
;;;249        if (err_code != NRF_SUCCESS)
0000b4  2800              CMP      r0,#0
0000b6  d106              BNE      |L1.198|
;;;250        {
;;;251            return err_code;
;;;252        }
;;;253        
;;;254        // Encode 128 bit UUIDs.
;;;255        err_code = uuid_list_sized_encode(p_uuid_list,
0000b8  4633              MOV      r3,r6
0000ba  2210              MOVS     r2,#0x10
0000bc  4629              MOV      r1,r5
0000be  4638              MOV      r0,r7
0000c0  9400              STR      r4,[sp,#0]
0000c2  f7fffffe          BL       uuid_list_sized_encode
                  |L1.198|
;;;256                                          adv_type_128,
;;;257                                          sizeof(ble_uuid128_t),
;;;258                                          p_encoded_data,
;;;259                                          p_len);
;;;260        if (err_code != NRF_SUCCESS)
;;;261        {
;;;262            return err_code;
;;;263        }
;;;264        
;;;265        return NRF_SUCCESS;
;;;266    }
0000c6  bdf8              POP      {r3-r7,pc}
;;;267    
                          ENDP

                  adv_data_encode PROC
;;;413    
;;;414    static uint32_t adv_data_encode(const ble_advdata_t * p_advdata,
0000c8  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;415                                    uint8_t *             p_encoded_data,
;;;416                                    uint8_t *             p_len)
;;;417    {
0000ca  b082              SUB      sp,sp,#8
;;;418        uint32_t err_code = NRF_SUCCESS;
0000cc  2600              MOVS     r6,#0
0000ce  4605              MOV      r5,r0                 ;417
;;;419        
;;;420        *p_len = 0;
0000d0  7016              STRB     r6,[r2,#0]
;;;421        
;;;422        // Encode name.
;;;423        if (p_advdata->name_type != BLE_ADVDATA_NO_NAME)
0000d2  7800              LDRB     r0,[r0,#0]
0000d4  4614              MOV      r4,r2                 ;417
0000d6  2800              CMP      r0,#0
0000d8  d005              BEQ      |L1.230|
;;;424        {
;;;425            err_code = name_encode(p_advdata, p_encoded_data, p_len);
0000da  4628              MOV      r0,r5
0000dc  9903              LDR      r1,[sp,#0xc]
0000de  f7fffffe          BL       name_encode
0000e2  0006              MOVS     r6,r0
;;;426            if (err_code != NRF_SUCCESS)
0000e4  d12d              BNE      |L1.322|
                  |L1.230|
;;;427            {
;;;428                return err_code;
;;;429            }
;;;430        }
;;;431        
;;;432        // Encode appearance.
;;;433        if (p_advdata->include_appearance)
0000e6  78a8              LDRB     r0,[r5,#2]
0000e8  2800              CMP      r0,#0
0000ea  d01b              BEQ      |L1.292|
0000ec  7820              LDRB     r0,[r4,#0]
0000ee  9f03              LDR      r7,[sp,#0xc]
0000f0  1d00              ADDS     r0,r0,#4
0000f2  281f              CMP      r0,#0x1f
0000f4  d824              BHI      |L1.320|
0000f6  4668              MOV      r0,sp
0000f8  df79              SVC      #0x79
0000fa  2800              CMP      r0,#0
0000fc  d121              BNE      |L1.322|
0000fe  7821              LDRB     r1,[r4,#0]
000100  2203              MOVS     r2,#3
000102  1c48              ADDS     r0,r1,#1
000104  7020              STRB     r0,[r4,#0]
000106  547a              STRB     r2,[r7,r1]
000108  7821              LDRB     r1,[r4,#0]
00010a  2219              MOVS     r2,#0x19
00010c  1c48              ADDS     r0,r1,#1
00010e  7020              STRB     r0,[r4,#0]
000110  547a              STRB     r2,[r7,r1]
000112  7820              LDRB     r0,[r4,#0]
000114  19c1              ADDS     r1,r0,r7
000116  4668              MOV      r0,sp
000118  8800              LDRH     r0,[r0,#0]
00011a  f7fffffe          BL       uint16_encode
00011e  7821              LDRB     r1,[r4,#0]
000120  1840              ADDS     r0,r0,r1
000122  7020              STRB     r0,[r4,#0]
                  |L1.292|
;;;434        {
;;;435            err_code = appearance_encode(p_encoded_data, p_len);
;;;436            if (err_code != NRF_SUCCESS)
;;;437            {
;;;438                return err_code;
;;;439            }
;;;440        }
;;;441        
;;;442        // Encode flags.
;;;443        if (p_advdata->flags.size > 0)
000124  88a9              LDRH     r1,[r5,#4]
000126  2900              CMP      r1,#0
000128  d023              BEQ      |L1.370|
;;;444        {
;;;445            err_code = uint8_array_encode(&p_advdata->flags,
00012a  2001              MOVS     r0,#1
00012c  4684              MOV      r12,r0
00012e  68aa              LDR      r2,[r5,#8]
000130  9803              LDR      r0,[sp,#0xc]
000132  2a00              CMP      r2,#0
000134  d007              BEQ      |L1.326|
000136  7822              LDRB     r2,[r4,#0]
000138  1853              ADDS     r3,r2,r1
00013a  1c9b              ADDS     r3,r3,#2
00013c  2b1f              CMP      r3,#0x1f
00013e  d904              BLS      |L1.330|
                  |L1.320|
000140  200c              MOVS     r0,#0xc
                  |L1.322|
;;;446                                          BLE_GAP_AD_TYPE_FLAGS,
;;;447                                          p_encoded_data,
;;;448                                          p_len);
;;;449            if (err_code != NRF_SUCCESS)
;;;450            {
;;;451                return err_code;
;;;452            }
;;;453        }
;;;454        
;;;455        // Encode TX power level.
;;;456        if (p_advdata->p_tx_power_level != NULL)
;;;457        {
;;;458            err_code = tx_power_level_encode(*p_advdata->p_tx_power_level, p_encoded_data, p_len);
;;;459            if (err_code != NRF_SUCCESS)
;;;460            {
;;;461                return err_code;
;;;462            }
;;;463        }
;;;464        
;;;465        // Encode 'more available' uuid list.
;;;466        if (p_advdata->uuids_more_available.uuid_cnt > 0)
;;;467        {
;;;468            err_code = uuid_list_encode(&p_advdata->uuids_more_available,
;;;469                                        BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE,
;;;470                                        BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE,
;;;471                                        p_encoded_data,
;;;472                                        p_len);
;;;473            if (err_code != NRF_SUCCESS)
;;;474            {
;;;475                return err_code;
;;;476            }
;;;477        }
;;;478        
;;;479        // Encode 'complete' uuid list.
;;;480        if (p_advdata->uuids_complete.uuid_cnt > 0)
;;;481        {
;;;482            err_code = uuid_list_encode(&p_advdata->uuids_complete,
;;;483                                        BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE,
;;;484                                        BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE,
;;;485                                        p_encoded_data,
;;;486                                        p_len);
;;;487            if (err_code != NRF_SUCCESS)
;;;488            {
;;;489                return err_code;
;;;490            }
;;;491        }
;;;492        
;;;493        // Encode 'solicited service' uuid list.
;;;494        if (p_advdata->uuids_solicited.uuid_cnt > 0)
;;;495        {
;;;496            err_code = uuid_list_encode(&p_advdata->uuids_solicited,
;;;497                                        BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT,
;;;498                                        BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT,
;;;499                                        p_encoded_data,
;;;500                                        p_len);
;;;501            if (err_code != NRF_SUCCESS)
;;;502            {
;;;503                return err_code;
;;;504            }
;;;505        }
;;;506        
;;;507        // Encode Slave Connection Interval Range.
;;;508        if (p_advdata->p_slave_conn_int != NULL)
;;;509        {
;;;510            err_code = conn_int_encode(p_advdata->p_slave_conn_int, p_encoded_data, p_len);
;;;511            if (err_code != NRF_SUCCESS)
;;;512            {
;;;513                return err_code;
;;;514            }
;;;515        }
;;;516        
;;;517        // Encode Manufacturer Specific Data.
;;;518        if (p_advdata->p_manuf_specific_data != NULL)
;;;519        {
;;;520            err_code = manuf_specific_data_encode(p_advdata->p_manuf_specific_data,
;;;521                                                  p_encoded_data,
;;;522                                                  p_len);
;;;523            if (err_code != NRF_SUCCESS)
;;;524            {
;;;525                return err_code;
;;;526            }
;;;527        }
;;;528        
;;;529        // Encode Service Data.
;;;530        if (p_advdata->service_data_count > 0)
;;;531        {
;;;532            err_code = service_data_encode(p_advdata, p_encoded_data, p_len);
;;;533            if (err_code != NRF_SUCCESS)
;;;534            {
;;;535                return err_code;
;;;536            }
;;;537        }
;;;538        
;;;539        return err_code;
;;;540    }
000142  b005              ADD      sp,sp,#0x14
000144  bdf0              POP      {r4-r7,pc}
                  |L1.326|
000146  2007              MOVS     r0,#7
000148  e7fb              B        |L1.322|
                  |L1.330|
00014a  4613              MOV      r3,r2
00014c  1c52              ADDS     r2,r2,#1
00014e  7022              STRB     r2,[r4,#0]
000150  1c49              ADDS     r1,r1,#1
000152  54c1              STRB     r1,[r0,r3]
000154  7822              LDRB     r2,[r4,#0]
000156  4667              MOV      r7,r12
000158  1c51              ADDS     r1,r2,#1
00015a  7021              STRB     r1,[r4,#0]
00015c  5487              STRB     r7,[r0,r2]
00015e  7823              LDRB     r3,[r4,#0]
000160  88aa              LDRH     r2,[r5,#4]
000162  1818              ADDS     r0,r3,r0
000164  68a9              LDR      r1,[r5,#8]
000166  f7fffffe          BL       __aeabi_memcpy
00016a  7820              LDRB     r0,[r4,#0]
00016c  7929              LDRB     r1,[r5,#4]
00016e  1840              ADDS     r0,r0,r1
000170  7020              STRB     r0,[r4,#0]
                  |L1.370|
000172  68e8              LDR      r0,[r5,#0xc]          ;456
000174  2800              CMP      r0,#0                 ;456
000176  d015              BEQ      |L1.420|
000178  2100              MOVS     r1,#0                 ;458
00017a  5641              LDRSB    r1,[r0,r1]            ;458
00017c  7822              LDRB     r2,[r4,#0]            ;458
00017e  468c              MOV      r12,r1                ;458
000180  1cd0              ADDS     r0,r2,#3              ;458
000182  9903              LDR      r1,[sp,#0xc]          ;458
000184  281f              CMP      r0,#0x1f              ;458
000186  d8db              BHI      |L1.320|
000188  1c50              ADDS     r0,r2,#1              ;458
00018a  2302              MOVS     r3,#2                 ;458
00018c  7020              STRB     r0,[r4,#0]            ;458
00018e  548b              STRB     r3,[r1,r2]            ;458
000190  7822              LDRB     r2,[r4,#0]            ;458
000192  230a              MOVS     r3,#0xa               ;458
000194  1c50              ADDS     r0,r2,#1              ;458
000196  7020              STRB     r0,[r4,#0]            ;458
000198  548b              STRB     r3,[r1,r2]            ;458
00019a  7820              LDRB     r0,[r4,#0]            ;458
00019c  4662              MOV      r2,r12                ;458
00019e  1c43              ADDS     r3,r0,#1              ;458
0001a0  7023              STRB     r3,[r4,#0]            ;458
0001a2  540a              STRB     r2,[r1,r0]            ;458
                  |L1.420|
0001a4  8a28              LDRH     r0,[r5,#0x10]         ;466
0001a6  2800              CMP      r0,#0                 ;466
0001a8  d009              BEQ      |L1.446|
0001aa  4628              MOV      r0,r5                 ;468
0001ac  9400              STR      r4,[sp,#0]            ;468
0001ae  2206              MOVS     r2,#6                 ;468
0001b0  2102              MOVS     r1,#2                 ;468
0001b2  3010              ADDS     r0,r0,#0x10           ;468
0001b4  9b03              LDR      r3,[sp,#0xc]          ;468
0001b6  f7fffffe          BL       uuid_list_encode
0001ba  0006              MOVS     r6,r0                 ;468
0001bc  d1c1              BNE      |L1.322|
                  |L1.446|
0001be  8b28              LDRH     r0,[r5,#0x18]         ;480
0001c0  2800              CMP      r0,#0                 ;480
0001c2  d009              BEQ      |L1.472|
0001c4  4628              MOV      r0,r5                 ;482
0001c6  9400              STR      r4,[sp,#0]            ;482
0001c8  2207              MOVS     r2,#7                 ;482
0001ca  2103              MOVS     r1,#3                 ;482
0001cc  3018              ADDS     r0,r0,#0x18           ;482
0001ce  9b03              LDR      r3,[sp,#0xc]          ;482
0001d0  f7fffffe          BL       uuid_list_encode
0001d4  0006              MOVS     r6,r0                 ;482
0001d6  d1b4              BNE      |L1.322|
                  |L1.472|
0001d8  8c28              LDRH     r0,[r5,#0x20]         ;494
0001da  462f              MOV      r7,r5                 ;496
0001dc  3720              ADDS     r7,r7,#0x20           ;496
0001de  2800              CMP      r0,#0                 ;494
0001e0  d008              BEQ      |L1.500|
0001e2  9400              STR      r4,[sp,#0]            ;496
0001e4  2215              MOVS     r2,#0x15              ;496
0001e6  2114              MOVS     r1,#0x14              ;496
0001e8  4638              MOV      r0,r7                 ;496
0001ea  9b03              LDR      r3,[sp,#0xc]          ;496
0001ec  f7fffffe          BL       uuid_list_encode
0001f0  0006              MOVS     r6,r0                 ;496
0001f2  d1a6              BNE      |L1.322|
                  |L1.500|
0001f4  6aa8              LDR      r0,[r5,#0x28]         ;508
0001f6  2800              CMP      r0,#0                 ;508
0001f8  d005              BEQ      |L1.518|
0001fa  4622              MOV      r2,r4                 ;510
0001fc  9903              LDR      r1,[sp,#0xc]          ;510
0001fe  f7fffffe          BL       conn_int_encode
000202  0006              MOVS     r6,r0                 ;510
000204  d19d              BNE      |L1.322|
                  |L1.518|
000206  6ae8              LDR      r0,[r5,#0x2c]         ;518
000208  2800              CMP      r0,#0                 ;518
00020a  d005              BEQ      |L1.536|
00020c  4622              MOV      r2,r4                 ;520
00020e  9903              LDR      r1,[sp,#0xc]          ;520
000210  f7fffffe          BL       manuf_specific_data_encode
000214  0006              MOVS     r6,r0                 ;520
000216  d194              BNE      |L1.322|
                  |L1.536|
000218  7d38              LDRB     r0,[r7,#0x14]         ;530
00021a  2800              CMP      r0,#0                 ;530
00021c  d006              BEQ      |L1.556|
00021e  4622              MOV      r2,r4                 ;532
000220  4628              MOV      r0,r5                 ;532
000222  9903              LDR      r1,[sp,#0xc]          ;532
000224  f7fffffe          BL       service_data_encode
000228  0006              MOVS     r6,r0                 ;532
00022a  d18a              BNE      |L1.322|
                  |L1.556|
00022c  4630              MOV      r0,r6                 ;539
00022e  e788              B        |L1.322|
;;;541    
                          ENDP

                  ble_advdata_set PROC
;;;569    
;;;570    uint32_t ble_advdata_set(const ble_advdata_t * p_advdata, const ble_advdata_t * p_srdata)
000230  b570              PUSH     {r4-r6,lr}
;;;571    {
000232  460d              MOV      r5,r1
000234  b092              SUB      sp,sp,#0x48
;;;572        uint32_t  err_code;
;;;573        uint8_t   len_advdata = 0;
000236  2100              MOVS     r1,#0
000238  466a              MOV      r2,sp
00023a  7011              STRB     r1,[r2,#0]
00023c  2407              MOVS     r4,#7
;;;574        uint8_t   len_srdata = 0;
00023e  7111              STRB     r1,[r2,#4]
;;;575        uint8_t   encoded_advdata[BLE_GAP_ADV_MAX_SIZE];
;;;576        uint8_t   encoded_srdata[BLE_GAP_ADV_MAX_SIZE];
;;;577        uint8_t * p_encoded_advdata;
;;;578        uint8_t * p_encoded_srdata;
;;;579    
;;;580        // Encode advertising data (if supplied).
;;;581        if (p_advdata != NULL)
000240  2800              CMP      r0,#0
000242  d012              BEQ      |L1.618|
000244  8881              LDRH     r1,[r0,#4]            ;571
000246  2900              CMP      r1,#0                 ;571
;;;582        {
;;;583            err_code = advdata_check(p_advdata);
000248  d005              BEQ      |L1.598|
00024a  6881              LDR      r1,[r0,#8]
00024c  2900              CMP      r1,#0
00024e  d002              BEQ      |L1.598|
000250  7809              LDRB     r1,[r1,#0]
000252  0749              LSLS     r1,r1,#29
000254  d402              BMI      |L1.604|
                  |L1.598|
000256  4620              MOV      r0,r4
                  |L1.600|
;;;584            if (err_code != NRF_SUCCESS)
;;;585            {
;;;586                return err_code;
;;;587            }
;;;588            
;;;589            err_code = adv_data_encode(p_advdata, encoded_advdata, &len_advdata);
;;;590            if (err_code != NRF_SUCCESS)
;;;591            {
;;;592                return err_code;
;;;593            }
;;;594            p_encoded_advdata = encoded_advdata;
;;;595        }
;;;596        else
;;;597        {
;;;598            p_encoded_advdata = NULL;
;;;599        }
;;;600        
;;;601        // Encode scan response data (if supplied).
;;;602        if (p_srdata != NULL)
;;;603        {
;;;604            err_code = srdata_check(p_srdata);
;;;605            if (err_code != NRF_SUCCESS)
;;;606            {
;;;607                return err_code;
;;;608            }
;;;609            
;;;610            err_code = adv_data_encode(p_srdata, encoded_srdata, &len_srdata);
;;;611            if (err_code != NRF_SUCCESS)
;;;612            {
;;;613                return err_code;
;;;614            }
;;;615            p_encoded_srdata = encoded_srdata;
;;;616        }
;;;617        else
;;;618        {
;;;619            p_encoded_srdata = NULL;
;;;620        }
;;;621    
;;;622        // Pass encoded advertising data and/or scan response data to the stack.
;;;623        return sd_ble_gap_adv_data_set(p_encoded_advdata, len_advdata, p_encoded_srdata, len_srdata);
;;;624    }
000258  b012              ADD      sp,sp,#0x48
00025a  bd70              POP      {r4-r6,pc}
                  |L1.604|
00025c  a902              ADD      r1,sp,#8              ;589
00025e  f7fffffe          BL       adv_data_encode
000262  2800              CMP      r0,#0                 ;590
000264  d1f8              BNE      |L1.600|
000266  ae02              ADD      r6,sp,#8              ;594
000268  e000              B        |L1.620|
                  |L1.618|
00026a  2600              MOVS     r6,#0                 ;598
                  |L1.620|
00026c  2d00              CMP      r5,#0                 ;602
00026e  d00b              BEQ      |L1.648|
000270  88a8              LDRH     r0,[r5,#4]            ;602
000272  2800              CMP      r0,#0                 ;602
000274  d1ef              BNE      |L1.598|
000276  aa01              ADD      r2,sp,#4              ;610
000278  a90a              ADD      r1,sp,#0x28           ;610
00027a  4628              MOV      r0,r5                 ;610
00027c  f7fffffe          BL       adv_data_encode
000280  2800              CMP      r0,#0                 ;611
000282  d1e9              BNE      |L1.600|
000284  aa0a              ADD      r2,sp,#0x28           ;615
000286  e000              B        |L1.650|
                  |L1.648|
000288  2200              MOVS     r2,#0                 ;619
                  |L1.650|
00028a  4668              MOV      r0,sp                 ;623
00028c  7903              LDRB     r3,[r0,#4]            ;623
00028e  7801              LDRB     r1,[r0,#0]            ;623
000290  4630              MOV      r0,r6                 ;623
000292  df72              SVC      #0x72                 ;623
000294  e7e0              B        |L1.600|
                          ENDP

                  uint16_encode PROC
;;;170     */
;;;171    static __INLINE uint8_t uint16_encode(uint16_t value, uint8_t * p_encoded_data)
000296  7008              STRB     r0,[r1,#0]
;;;172    {
;;;173        p_encoded_data[0] = (uint8_t) ((value & 0x00FF) >> 0);
;;;174        p_encoded_data[1] = (uint8_t) ((value & 0xFF00) >> 8);
000298  0a00              LSRS     r0,r0,#8
00029a  7048              STRB     r0,[r1,#1]
;;;175        return sizeof(uint16_t);
00029c  2002              MOVS     r0,#2
;;;176    }
00029e  4770              BX       lr
;;;177        
                          ENDP

                  name_encode PROC
;;;32     
;;;33     static uint32_t name_encode(const ble_advdata_t * p_advdata,
0002a0  b5f8              PUSH     {r3-r7,lr}
;;;34                                 uint8_t *             p_encoded_data,
;;;35                                 uint8_t *             p_len)
;;;36     {
;;;37         uint32_t err_code;
;;;38         uint16_t rem_adv_data_len;
;;;39         uint16_t actual_length;
;;;40         uint8_t  adv_data_format;
;;;41         uint8_t  adv_offset;
;;;42         
;;;43         adv_offset = *p_len;
0002a2  7814              LDRB     r4,[r2,#0]
0002a4  4607              MOV      r7,r0                 ;36
;;;44         
;;;45         
;;;46         // Check for buffer overflow.
;;;47         if ((adv_offset + ADV_DATA_OFFSET > BLE_GAP_ADV_MAX_SIZE) ||
0002a6  1ca0              ADDS     r0,r4,#2
0002a8  4615              MOV      r5,r2                 ;36
0002aa  460e              MOV      r6,r1                 ;36
0002ac  281f              CMP      r0,#0x1f
0002ae  d803              BHI      |L1.696|
;;;48            ((p_advdata->short_name_len + ADV_DATA_OFFSET) > BLE_GAP_ADV_MAX_SIZE))
0002b0  7878              LDRB     r0,[r7,#1]
0002b2  1c80              ADDS     r0,r0,#2
0002b4  281f              CMP      r0,#0x1f
0002b6  d901              BLS      |L1.700|
                  |L1.696|
;;;49         {
;;;50             return NRF_ERROR_DATA_SIZE;
0002b8  200c              MOVS     r0,#0xc
                  |L1.698|
;;;51         }
;;;52         actual_length = rem_adv_data_len = (BLE_GAP_ADV_MAX_SIZE - adv_offset - ADV_FLAG_OFFSET);
;;;53     
;;;54         // Get GAP device name and length
;;;55         err_code = sd_ble_gap_device_name_get(&p_encoded_data[adv_offset + ADV_DATA_OFFSET],
;;;56                                               &actual_length);
;;;57         if (err_code != NRF_SUCCESS)
;;;58         {
;;;59             return err_code;
;;;60         }
;;;61         
;;;62         // Check if device internd to use short name and it can fit available data size.
;;;63         if ((p_advdata->name_type == BLE_ADVDATA_FULL_NAME) && (actual_length <= rem_adv_data_len))
;;;64         {
;;;65             // Complete device name can fit, setting Complete Name in Adv Data.
;;;66             adv_data_format = BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME;
;;;67             rem_adv_data_len = actual_length;
;;;68         }
;;;69         else
;;;70         {
;;;71             // Else short name needs to be used. Or application has requested use of short name.
;;;72             adv_data_format = BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME;
;;;73             
;;;74             // If application has set a preference on the short name size, it needs to be considered,
;;;75             // else fit what can be fit.
;;;76             if ((p_advdata->short_name_len != 0) && (p_advdata->short_name_len <= rem_adv_data_len))
;;;77             {
;;;78                 // Short name fits available size.
;;;79                 rem_adv_data_len = p_advdata->short_name_len;
;;;80             }
;;;81             // Else whatever can fit the data buffer will be packed.
;;;82             else
;;;83             {
;;;84                 rem_adv_data_len = actual_length;
;;;85             }
;;;86         }
;;;87         
;;;88         // Complete name field in encoded data.
;;;89         p_encoded_data[adv_offset++] = rem_adv_data_len + 1;
;;;90         p_encoded_data[adv_offset++] = adv_data_format;
;;;91         (*p_len) += (rem_adv_data_len + ADV_DATA_OFFSET);
;;;92         
;;;93         return NRF_SUCCESS;
;;;94     }
0002ba  bdf8              POP      {r3-r7,pc}
                  |L1.700|
0002bc  201d              MOVS     r0,#0x1d              ;52
0002be  1b00              SUBS     r0,r0,r4              ;52
0002c0  b280              UXTH     r0,r0                 ;52
0002c2  4669              MOV      r1,sp                 ;52
0002c4  4686              MOV      lr,r0                 ;52
0002c6  8008              STRH     r0,[r1,#0]            ;52
0002c8  1930              ADDS     r0,r6,r4              ;55
0002ca  1c80              ADDS     r0,r0,#2              ;55
0002cc  df7d              SVC      #0x7d                 ;55
0002ce  2800              CMP      r0,#0                 ;57
0002d0  d1f3              BNE      |L1.698|
0002d2  7838              LDRB     r0,[r7,#0]            ;63
0002d4  2802              CMP      r0,#2                 ;63
0002d6  d105              BNE      |L1.740|
0002d8  4668              MOV      r0,sp                 ;63
0002da  8800              LDRH     r0,[r0,#0]            ;63
0002dc  4570              CMP      r0,lr                 ;63
0002de  d801              BHI      |L1.740|
0002e0  2109              MOVS     r1,#9                 ;66
0002e2  e007              B        |L1.756|
                  |L1.740|
0002e4  7878              LDRB     r0,[r7,#1]            ;76
0002e6  2108              MOVS     r1,#8                 ;72
0002e8  2800              CMP      r0,#0                 ;76
0002ea  d001              BEQ      |L1.752|
0002ec  4570              CMP      r0,lr                 ;76
0002ee  d901              BLS      |L1.756|
                  |L1.752|
0002f0  4668              MOV      r0,sp                 ;84
0002f2  8800              LDRH     r0,[r0,#0]            ;84
                  |L1.756|
0002f4  1c42              ADDS     r2,r0,#1              ;89
0002f6  5532              STRB     r2,[r6,r4]            ;89
0002f8  1c64              ADDS     r4,r4,#1              ;89
0002fa  b2e2              UXTB     r2,r4                 ;89
0002fc  54b1              STRB     r1,[r6,r2]            ;90
0002fe  7829              LDRB     r1,[r5,#0]            ;91
000300  1c80              ADDS     r0,r0,#2              ;91
000302  1808              ADDS     r0,r1,r0              ;91
000304  7028              STRB     r0,[r5,#0]            ;91
000306  2000              MOVS     r0,#0                 ;93
000308  bdf8              POP      {r3-r7,pc}
;;;95     
                          ENDP

                  conn_int_encode PROC
;;;305    
;;;306    static uint32_t conn_int_encode(const ble_advdata_conn_int_t * p_conn_int,
00030a  b5f8              PUSH     {r3-r7,lr}
;;;307                                    uint8_t *                      p_encoded_data,
;;;308                                    uint8_t *                      p_len)
;;;309    {
00030c  460d              MOV      r5,r1
;;;310        uint32_t err_code;
;;;311    
;;;312        // Check for buffer overflow.
;;;313        if ((*p_len) + ADV_DATA_OFFSET + 2 * sizeof(uint16_le_t) > BLE_GAP_ADV_MAX_SIZE)
00030e  7811              LDRB     r1,[r2,#0]
000310  4606              MOV      r6,r0                 ;309
000312  1d88              ADDS     r0,r1,#6
000314  4614              MOV      r4,r2                 ;309
000316  281f              CMP      r0,#0x1f
000318  d901              BLS      |L1.798|
;;;314        {
;;;315            return NRF_ERROR_DATA_SIZE;
00031a  200c              MOVS     r0,#0xc
                  |L1.796|
;;;316        }
;;;317        
;;;318        // Check parameters.
;;;319        err_code = conn_int_check(p_conn_int);
;;;320        if (err_code != NRF_SUCCESS)
;;;321        {
;;;322            return err_code;
;;;323        }
;;;324        
;;;325        // Encode Length and AD Type.
;;;326        p_encoded_data[(*p_len)++] = 1 + 2 * sizeof(uint16_le_t);
;;;327        p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE;
;;;328        
;;;329        // Encode Minimum and Maximum Connection Intervals.
;;;330        (*p_len) += uint16_encode(p_conn_int->min_conn_interval, &p_encoded_data[*p_len]);
;;;331        (*p_len) += uint16_encode(p_conn_int->max_conn_interval, &p_encoded_data[*p_len]);
;;;332        
;;;333        return NRF_SUCCESS;
;;;334    }
00031c  bdf8              POP      {r3-r7,pc}
                  |L1.798|
00031e  8833              LDRH     r3,[r6,#0]
000320  2007              MOVS     r0,#7
000322  2b06              CMP      r3,#6
000324  d3fa              BCC      |L1.796|
000326  2719              MOVS     r7,#0x19              ;319
000328  01ff              LSLS     r7,r7,#7              ;319
00032a  42bb              CMP      r3,r7                 ;319
00032c  d902              BLS      |L1.820|
00032e  4a4e              LDR      r2,|L1.1128|
000330  4293              CMP      r3,r2                 ;319
000332  d1f3              BNE      |L1.796|
                  |L1.820|
000334  8872              LDRH     r2,[r6,#2]            ;319
000336  2a06              CMP      r2,#6                 ;319
000338  d3f0              BCC      |L1.796|
00033a  42ba              CMP      r2,r7                 ;319
00033c  d902              BLS      |L1.836|
00033e  4f4a              LDR      r7,|L1.1128|
000340  42ba              CMP      r2,r7                 ;319
000342  d1eb              BNE      |L1.796|
                  |L1.836|
000344  4f48              LDR      r7,|L1.1128|
000346  42bb              CMP      r3,r7                 ;319
000348  d003              BEQ      |L1.850|
00034a  42ba              CMP      r2,r7                 ;319
00034c  d001              BEQ      |L1.850|
00034e  4293              CMP      r3,r2                 ;319
000350  d8e4              BHI      |L1.796|
                  |L1.850|
000352  1c48              ADDS     r0,r1,#1              ;326
000354  2205              MOVS     r2,#5                 ;326
000356  7020              STRB     r0,[r4,#0]            ;326
000358  546a              STRB     r2,[r5,r1]            ;326
00035a  7820              LDRB     r0,[r4,#0]            ;327
00035c  2212              MOVS     r2,#0x12              ;327
00035e  1c41              ADDS     r1,r0,#1              ;327
000360  7021              STRB     r1,[r4,#0]            ;327
000362  542a              STRB     r2,[r5,r0]            ;327
000364  7820              LDRB     r0,[r4,#0]            ;330
000366  1941              ADDS     r1,r0,r5              ;330
000368  8830              LDRH     r0,[r6,#0]            ;330
00036a  f7fffffe          BL       uint16_encode
00036e  7821              LDRB     r1,[r4,#0]            ;330
000370  1840              ADDS     r0,r0,r1              ;330
000372  b2c0              UXTB     r0,r0                 ;330
000374  7020              STRB     r0,[r4,#0]            ;330
000376  1941              ADDS     r1,r0,r5              ;331
000378  8870              LDRH     r0,[r6,#2]            ;331
00037a  f7fffffe          BL       uint16_encode
00037e  7821              LDRB     r1,[r4,#0]            ;331
000380  1840              ADDS     r0,r0,r1              ;331
000382  7020              STRB     r0,[r4,#0]            ;331
000384  2000              MOVS     r0,#0                 ;333
000386  bdf8              POP      {r3-r7,pc}
;;;335    
                          ENDP

                  manuf_specific_data_encode PROC
;;;336    
;;;337    static uint32_t manuf_specific_data_encode(const ble_advdata_manuf_data_t * p_manuf_sp_data,
000388  b570              PUSH     {r4-r6,lr}
;;;338                                               uint8_t *                        p_encoded_data,
;;;339                                               uint8_t *                        p_len)
;;;340    {
00038a  4605              MOV      r5,r0
;;;341        uint8_t data_size = sizeof(uint16_le_t) + p_manuf_sp_data->data.size;
00038c  7900              LDRB     r0,[r0,#4]
00038e  460e              MOV      r6,r1                 ;340
000390  1c80              ADDS     r0,r0,#2
000392  4614              MOV      r4,r2                 ;340
000394  b2c0              UXTB     r0,r0
;;;342        
;;;343        // Check for buffer overflow.
;;;344        if ((*p_len) + ADV_DATA_OFFSET + data_size > BLE_GAP_ADV_MAX_SIZE)
000396  7811              LDRB     r1,[r2,#0]
000398  1c82              ADDS     r2,r0,#2
00039a  188a              ADDS     r2,r1,r2
00039c  2a1f              CMP      r2,#0x1f
00039e  d901              BLS      |L1.932|
;;;345        {
;;;346            return NRF_ERROR_DATA_SIZE;
0003a0  200c              MOVS     r0,#0xc
;;;347        }
;;;348    
;;;349        // Encode Length and AD Type.
;;;350        p_encoded_data[(*p_len)++] = 1 + data_size;
;;;351        p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA;
;;;352        
;;;353        // Encode Company Identifier.
;;;354        (*p_len) += uint16_encode(p_manuf_sp_data->company_identifier, &p_encoded_data[*p_len]);
;;;355        
;;;356        // Encode additional manufacturer specific data.
;;;357        if (p_manuf_sp_data->data.size > 0)
;;;358        {
;;;359            if (p_manuf_sp_data->data.p_data == NULL)
;;;360            {
;;;361                return NRF_ERROR_INVALID_PARAM;
;;;362            }
;;;363            memcpy(&p_encoded_data[*p_len], p_manuf_sp_data->data.p_data, p_manuf_sp_data->data.size);
;;;364            (*p_len) += p_manuf_sp_data->data.size;
;;;365        }
;;;366        
;;;367        return NRF_SUCCESS;
;;;368    }
0003a2  bd70              POP      {r4-r6,pc}
                  |L1.932|
0003a4  460a              MOV      r2,r1
0003a6  1c49              ADDS     r1,r1,#1              ;350
0003a8  7021              STRB     r1,[r4,#0]            ;350
0003aa  1c40              ADDS     r0,r0,#1              ;350
0003ac  54b0              STRB     r0,[r6,r2]            ;350
0003ae  7820              LDRB     r0,[r4,#0]            ;351
0003b0  22ff              MOVS     r2,#0xff              ;351
0003b2  1c41              ADDS     r1,r0,#1              ;351
0003b4  7021              STRB     r1,[r4,#0]            ;351
0003b6  5432              STRB     r2,[r6,r0]            ;351
0003b8  7820              LDRB     r0,[r4,#0]            ;354
0003ba  1981              ADDS     r1,r0,r6              ;354
0003bc  8828              LDRH     r0,[r5,#0]            ;354
0003be  f7fffffe          BL       uint16_encode
0003c2  7821              LDRB     r1,[r4,#0]            ;354
0003c4  1840              ADDS     r0,r0,r1              ;354
0003c6  b2c0              UXTB     r0,r0                 ;354
0003c8  7020              STRB     r0,[r4,#0]            ;354
0003ca  88aa              LDRH     r2,[r5,#4]            ;357
0003cc  2a00              CMP      r2,#0                 ;357
0003ce  d009              BEQ      |L1.996|
0003d0  68a9              LDR      r1,[r5,#8]            ;359
0003d2  2900              CMP      r1,#0                 ;359
0003d4  d008              BEQ      |L1.1000|
0003d6  1980              ADDS     r0,r0,r6              ;363
0003d8  f7fffffe          BL       __aeabi_memcpy
0003dc  7820              LDRB     r0,[r4,#0]            ;364
0003de  7929              LDRB     r1,[r5,#4]            ;364
0003e0  1840              ADDS     r0,r0,r1              ;364
0003e2  7020              STRB     r0,[r4,#0]            ;364
                  |L1.996|
0003e4  2000              MOVS     r0,#0                 ;367
0003e6  bd70              POP      {r4-r6,pc}
                  |L1.1000|
0003e8  2007              MOVS     r0,#7                 ;361
0003ea  bd70              POP      {r4-r6,pc}
;;;369    
                          ENDP

                  service_data_encode PROC
;;;370    
;;;371    static uint32_t service_data_encode(const ble_advdata_t * p_advdata,
0003ec  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;372                                        uint8_t *             p_encoded_data,
;;;373                                        uint8_t *             p_len)
;;;374    {
0003ee  b082              SUB      sp,sp,#8
;;;375        uint8_t i;
;;;376    
;;;377        // Check parameter consistency.
;;;378        if (p_advdata->p_service_data_array == NULL)
0003f0  9802              LDR      r0,[sp,#8]
0003f2  4614              MOV      r4,r2                 ;374
0003f4  6b00              LDR      r0,[r0,#0x30]
0003f6  460f              MOV      r7,r1                 ;374
0003f8  2800              CMP      r0,#0
0003fa  d032              BEQ      |L1.1122|
0003fc  9802              LDR      r0,[sp,#8]            ;374
;;;379        {
;;;380            return NRF_ERROR_INVALID_PARAM;
;;;381        }
;;;382        
;;;383        for (i = 0; i < p_advdata->service_data_count; i++)
0003fe  2500              MOVS     r5,#0
000400  3020              ADDS     r0,r0,#0x20           ;374
000402  9000              STR      r0,[sp,#0]
000404  e028              B        |L1.1112|
                  |L1.1030|
;;;384        {
;;;385            ble_advdata_service_data_t * p_service_data;
;;;386            uint8_t                      data_size;
;;;387            
;;;388            p_service_data = &p_advdata->p_service_data_array[i];
000406  9802              LDR      r0,[sp,#8]
000408  6b01              LDR      r1,[r0,#0x30]
00040a  200c              MOVS     r0,#0xc
00040c  4368              MULS     r0,r5,r0
00040e  180e              ADDS     r6,r1,r0
;;;389            data_size      = sizeof(uint16_le_t) + p_service_data->data.size;
;;;390        
;;;391            // Encode Length and AD Type.
;;;392            p_encoded_data[(*p_len)++] = 1 + data_size;
000410  7821              LDRB     r1,[r4,#0]
000412  7930              LDRB     r0,[r6,#4]            ;389
000414  1c4a              ADDS     r2,r1,#1
000416  7022              STRB     r2,[r4,#0]
000418  1cc0              ADDS     r0,r0,#3
00041a  5478              STRB     r0,[r7,r1]
;;;393            p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_SERVICE_DATA;
00041c  7820              LDRB     r0,[r4,#0]
00041e  2216              MOVS     r2,#0x16
000420  1c41              ADDS     r1,r0,#1
000422  7021              STRB     r1,[r4,#0]
000424  543a              STRB     r2,[r7,r0]
;;;394            
;;;395            // Encode service UUID.
;;;396            (*p_len) += uint16_encode(p_service_data->service_uuid, &p_encoded_data[*p_len]);
000426  7820              LDRB     r0,[r4,#0]
000428  19c1              ADDS     r1,r0,r7
00042a  8830              LDRH     r0,[r6,#0]
00042c  f7fffffe          BL       uint16_encode
000430  7821              LDRB     r1,[r4,#0]
000432  1840              ADDS     r0,r0,r1
000434  b2c0              UXTB     r0,r0
000436  7020              STRB     r0,[r4,#0]
;;;397            
;;;398            // Encode additional service data.
;;;399            if (p_service_data->data.size > 0)
000438  88b2              LDRH     r2,[r6,#4]
00043a  2a00              CMP      r2,#0
00043c  d009              BEQ      |L1.1106|
;;;400            {
;;;401                if (p_service_data->data.p_data == NULL)
00043e  68b1              LDR      r1,[r6,#8]
000440  2900              CMP      r1,#0
000442  d00e              BEQ      |L1.1122|
;;;402                {
;;;403                    return NRF_ERROR_INVALID_PARAM;
;;;404                }
;;;405                memcpy(&p_encoded_data[*p_len], p_service_data->data.p_data, p_service_data->data.size);
000444  19c0              ADDS     r0,r0,r7
000446  f7fffffe          BL       __aeabi_memcpy
;;;406                (*p_len) += p_service_data->data.size;
00044a  7820              LDRB     r0,[r4,#0]
00044c  7931              LDRB     r1,[r6,#4]
00044e  1840              ADDS     r0,r0,r1
000450  7020              STRB     r0,[r4,#0]
                  |L1.1106|
000452  1c6d              ADDS     r5,r5,#1
000454  9800              LDR      r0,[sp,#0]            ;383
000456  b2ed              UXTB     r5,r5                 ;383
                  |L1.1112|
000458  7d00              LDRB     r0,[r0,#0x14]         ;383
00045a  42a8              CMP      r0,r5                 ;383
00045c  d8d3              BHI      |L1.1030|
;;;407            }
;;;408        }
;;;409        
;;;410        return NRF_SUCCESS;
00045e  2000              MOVS     r0,#0
;;;411    }
000460  e66f              B        |L1.322|
                  |L1.1122|
000462  2007              MOVS     r0,#7                 ;403
000464  e66d              B        |L1.322|
;;;412    
                          ENDP

000466  0000              DCW      0x0000
                  |L1.1128|
                          DCD      0x0000ffff

;*** Start embedded assembler ***

#line 1 "..\\Source\\ble\\ble_advdata.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_ble_advdata_c_cb25090c____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_ble_advdata_c_cb25090c____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_ble_advdata_c_cb25090c____REVSH|
#line 144
|__asm___13_ble_advdata_c_cb25090c____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
