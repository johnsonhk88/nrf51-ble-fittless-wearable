; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\adc_heart_rate.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\adc_heart_rate.d --feedback=.\obj\ak2_v1_1_0.fed --cpu=Cortex-M0 --apcs=interwork -O3 --diag_suppress=9931 -I..\Include -I..\user -I..\Include\app_common -I..\Include\ble -I..\Include\ble\ble_services -I..\Include\s110 -I..\Include\boards -I..\Include\sd_common -IC:\Johnson_project\2016_Project\BLE_Pedometer\Fittless_wearable\firmware_design\git-project\arm\RTE -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.6.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DNRF51 -DNRF51 -DDEBUG_NRF_USER -DSETUPA -DBOARD_AKII -DBLE_STACK_SUPPORT_REQD --omf_browse=.\obj\adc_heart_rate.crf ..\user\adc_heart_rate.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ADC_Heart_Rate_Init PROC
;;;53     // inital ADC Heart Rate I
;;;54     void ADC_Heart_Rate_Init(uint8_t  ADC_res, uint8_t ADC_input_select, uint8_t ADC_ISR_Enable)
000000  020b              LSLS     r3,r1,#8
;;;55     	
;;;56     {
;;;57       // uint32_t err_code;
;;;58     
;;;59         // Configure ADC
;;;60     	  NRF_ADC->CONFIG     = (ADC_res                                    << ADC_CONFIG_RES_Pos)     |    // 
000002  4303              ORRS     r3,r3,r0
000004  2008              MOVS     r0,#8
000006  4974              LDR      r1,|L1.472|
000008  4303              ORRS     r3,r3,r0
00000a  604b              STR      r3,[r1,#4]
;;;61                               (ADC_CONFIG_INPSEL_AnalogInputOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos)  |    // Analog input/3 prescaling input
;;;62                               (ADC_CONFIG_REFSEL_VBG                      << ADC_CONFIG_REFSEL_Pos)  |   // Use internal 1.2V bandgap voltage
;;;63                               (ADC_input_select                           << ADC_CONFIG_PSEL_Pos)    |
;;;64                               (ADC_CONFIG_EXTREFSEL_None                  << ADC_CONFIG_EXTREFSEL_Pos);
;;;65         NRF_ADC->EVENTS_END = 0;
00000c  4b73              LDR      r3,|L1.476|
00000e  2000              MOVS     r0,#0
000010  6018              STR      r0,[r3,#0]
;;;66     	
;;;67     	
;;;68     	
;;;69     	NRF_ADC->ENABLE = 1;  
000012  2001              MOVS     r0,#1
000014  6008              STR      r0,[r1,#0]
;;;70         // Check interrupt enable  
;;;71       if(ADC_ISR_Enable)
000016  2a00              CMP      r2,#0
000018  d00b              BEQ      |L1.50|
;;;72             {
;;;73                 NRF_ADC->INTENSET = ADC_INTENSET_END_Msk;
00001a  4971              LDR      r1,|L1.480|
00001c  6048              STR      r0,[r1,#4]
00001e  4871              LDR      r0,|L1.484|
000020  6801              LDR      r1,[r0,#0]
000022  0209              LSLS     r1,r1,#8
000024  0a09              LSRS     r1,r1,#8
000026  0702              LSLS     r2,r0,#28
000028  4311              ORRS     r1,r1,r2
00002a  6001              STR      r1,[r0,#0]
00002c  496e              LDR      r1,|L1.488|
00002e  2080              MOVS     r0,#0x80
000030  6008              STR      r0,[r1,#0]
                  |L1.50|
;;;74                 NVIC_SetPriority(ADC_IRQn, 1);
;;;75                 NVIC_EnableIRQ(ADC_IRQn);
;;;76             }
;;;77     
;;;78     }	
000032  4770              BX       lr
;;;79     
                          ENDP

                  ADC_IRQHandler PROC
;;;80     void ADC_IRQHandler(void)  //中断函数
000034  b510              PUSH     {r4,lr}
;;;81     {
;;;82         
;;;83          if (NRF_ADC->EVENTS_END != 0) 
000036  4869              LDR      r0,|L1.476|
000038  6803              LDR      r3,[r0,#0]
00003a  2100              MOVS     r1,#0
;;;84     			{
;;;85             NRF_ADC->EVENTS_END     = 0;               // clear evnt
;;;86             adc_result              = NRF_ADC->RESULT;  //读取adc的值
00003c  4a66              LDR      r2,|L1.472|
00003e  2b00              CMP      r3,#0                 ;83
000040  d00a              BEQ      |L1.88|
000042  6001              STR      r1,[r0,#0]            ;85
000044  6893              LDR      r3,[r2,#8]
000046  4869              LDR      r0,|L1.492|
000048  80c3              STRH     r3,[r0,#6]
;;;87     				//printf("ADC Heart Raw Data:%d\r\n",adc_result);
;;;88     				HRM_Update=1;
00004a  2301              MOVS     r3,#1
00004c  7043              STRB     r3,[r0,#1]
;;;89     				ADC_Sample_Per_Sec++;
00004e  68c4              LDR      r4,[r0,#0xc]  ; ADC_Sample_Per_Sec
000050  1c64              ADDS     r4,r4,#1
;;;90             NRF_ADC->TASKS_STOP     = 1;
000052  60c4              STR      r4,[r0,#0xc]  ; ADC_Sample_Per_Sec
000054  4866              LDR      r0,|L1.496|
000056  6043              STR      r3,[r0,#4]
                  |L1.88|
;;;91         }
;;;92         NRF_ADC->ENABLE     = ADC_ENABLE_ENABLE_Disabled;
000058  6011              STR      r1,[r2,#0]
;;;93     }
00005a  bd10              POP      {r4,pc}
;;;94     void adc_start(void)  //开始中断
                          ENDP

                  adc_start PROC
00005c  4863              LDR      r0,|L1.492|
;;;95     {
;;;96     	if((HRM_Update==0) &&(HRM_Run==1))
00005e  7841              LDRB     r1,[r0,#1]  ; HRM_Update
000060  2900              CMP      r1,#0
000062  d109              BNE      |L1.120|
000064  7800              LDRB     r0,[r0,#0]  ; HRM_Run
000066  2801              CMP      r0,#1
000068  d106              BNE      |L1.120|
;;;97     	{	
;;;98         NRF_ADC->ENABLE     = ADC_ENABLE_ENABLE_Enabled;
00006a  495b              LDR      r1,|L1.472|
00006c  6008              STR      r0,[r1,#0]
;;;99     
;;;100        NRF_ADC->EVENTS_END  = 0;    
00006e  4a5b              LDR      r2,|L1.476|
000070  2100              MOVS     r1,#0
000072  6011              STR      r1,[r2,#0]
;;;101        NRF_ADC->TASKS_START = 1;
000074  495e              LDR      r1,|L1.496|
000076  6008              STR      r0,[r1,#0]
                  |L1.120|
;;;102    	}	
;;;103    }
000078  4770              BX       lr
;;;104    
                          ENDP

                  adc_Heart_Signal_Process PROC
;;;117    
;;;118    void adc_Heart_Signal_Process(void)
00007a  b5f8              PUSH     {r3-r7,lr}
;;;119    {
;;;120    	int i=0;
;;;121     Signal=  adc_result;  // copy Adc result
00007c  4c5b              LDR      r4,|L1.492|
00007e  88e0              LDRH     r0,[r4,#6]  ; adc_result
000080  8160              STRH     r0,[r4,#0xa]
;;;122     sampleCounter++;      // sample counter+1 1ms	
000082  69a0              LDR      r0,[r4,#0x18]  ; sampleCounter
000084  1c40              ADDS     r0,r0,#1
000086  61a0              STR      r0,[r4,#0x18]  ; sampleCounter
;;;123     Pulse_Timing = sampleCounter - lastBeatTime;  // monitor the time since the last beat to avoid noise
000088  69a0              LDR      r0,[r4,#0x18]  ; sampleCounter
00008a  69e1              LDR      r1,[r4,#0x1c]  ; lastBeatTime
00008c  1a40              SUBS     r0,r0,r1
00008e  6320              STR      r0,[r4,#0x30]  ; Pulse_Timing
;;;124    	
;;;125     //  find trough of the pulse wave
;;;126      if((Signal < thresh) && (Pulse_Timing > (IBI/5)*3))
000090  8960              LDRH     r0,[r4,#0xa]  ; Signal
000092  6aa1              LDR      r1,[r4,#0x28]  ; thresh
000094  4288              CMP      r0,r1
000096  da0e              BGE      |L1.182|
000098  2105              MOVS     r1,#5
00009a  6b60              LDR      r0,[r4,#0x34]  ; IBI
00009c  f7fffffe          BL       __aeabi_idivmod
0000a0  0041              LSLS     r1,r0,#1
0000a2  1840              ADDS     r0,r0,r1
0000a4  6b21              LDR      r1,[r4,#0x30]  ; Pulse_Timing
0000a6  4288              CMP      r0,r1
0000a8  d205              BCS      |L1.182|
;;;127    	{      
;;;128    		// avoid dichrotic noise by waiting 3/5 of last IBI
;;;129         if (Signal < T)
0000aa  8960              LDRH     r0,[r4,#0xa]  ; Signal
0000ac  6a61              LDR      r1,[r4,#0x24]  ; T
0000ae  4288              CMP      r0,r1
0000b0  da01              BGE      |L1.182|
;;;130    		 {                        // T is the trough
;;;131              T = Signal;         // update new lowest point in pulse wave 
0000b2  8960              LDRH     r0,[r4,#0xa]  ; Signal
0000b4  6260              STR      r0,[r4,#0x24]  ; T
                  |L1.182|
;;;132          }
;;;133      } 
;;;134    	// update new Peak 
;;;135    	if(Signal > thresh && Signal > P)
0000b6  8960              LDRH     r0,[r4,#0xa]  ; Signal
0000b8  6aa1              LDR      r1,[r4,#0x28]  ; thresh
0000ba  4288              CMP      r0,r1
0000bc  dd05              BLE      |L1.202|
0000be  8960              LDRH     r0,[r4,#0xa]  ; Signal
0000c0  6a21              LDR      r1,[r4,#0x20]  ; P
0000c2  4288              CMP      r0,r1
0000c4  dd01              BLE      |L1.202|
;;;136    		{
;;;137    		// thresh condition helps avoid noise
;;;138            P = Signal;                             // P is the peak
0000c6  8960              LDRH     r0,[r4,#0xa]  ; Signal
0000c8  6220              STR      r0,[r4,#0x20]  ; P
                  |L1.202|
;;;139        }                                        // keep track of highest point in pulse wave
;;;140    	
;;;141     //  NOW IT'S TIME TO LOOK FOR THE HEART BEAT
;;;142      // signal surges up in value every time there is a pulse
;;;143    if (Pulse_Timing > ADC_Heart_StartTime)
0000ca  6b20              LDR      r0,[r4,#0x30]  ; Pulse_Timing
;;;144    	{                                   
;;;145    	 // avoid high frequency noise
;;;146      if ( (Signal > thresh) && (Pulse == 0) && (Pulse_Timing > (IBI/5)*3) )
;;;147    		{        
;;;148        Pulse = 1;                        // set the Pulse flag when we think there is a pulse
0000cc  2701              MOVS     r7,#1
0000ce  2500              MOVS     r5,#0
0000d0  28fa              CMP      r0,#0xfa              ;143
0000d2  d959              BLS      |L1.392|
0000d4  8960              LDRH     r0,[r4,#0xa]          ;146  ; Signal
0000d6  6aa1              LDR      r1,[r4,#0x28]         ;146  ; thresh
0000d8  4288              CMP      r0,r1                 ;146
0000da  dd55              BLE      |L1.392|
0000dc  7920              LDRB     r0,[r4,#4]            ;146  ; Pulse
0000de  2800              CMP      r0,#0                 ;146
0000e0  d152              BNE      |L1.392|
0000e2  2105              MOVS     r1,#5                 ;146
0000e4  6b60              LDR      r0,[r4,#0x34]         ;146  ; IBI
0000e6  f7fffffe          BL       __aeabi_idivmod
0000ea  0041              LSLS     r1,r0,#1              ;146
0000ec  1840              ADDS     r0,r0,r1              ;146
0000ee  6b21              LDR      r1,[r4,#0x30]         ;146  ; Pulse_Timing
0000f0  4288              CMP      r0,r1                 ;146
0000f2  d249              BCS      |L1.392|
0000f4  7127              STRB     r7,[r4,#4]
;;;149       // digitalWrite(blinkPin,HIGH);                // turn on pin 13 LED
;;;150    	//	nrf_gpio_pin_set( HeartRead_LED);	
;;;151        IBI = sampleCounter - lastBeatTime;         // Update IBI measure time between beats in mS
0000f6  69a0              LDR      r0,[r4,#0x18]  ; sampleCounter
0000f8  69e1              LDR      r1,[r4,#0x1c]  ; lastBeatTime
0000fa  1a40              SUBS     r0,r0,r1
0000fc  6360              STR      r0,[r4,#0x34]  ; IBI
;;;152    			lastBeatTime = sampleCounter;               // current time = lastBesttime of time for next pulse	
0000fe  69a0              LDR      r0,[r4,#0x18]  ; sampleCounter
000100  61e0              STR      r0,[r4,#0x1c]  ; lastBeatTime
;;;153    		
;;;154    			    if(secondBeat==1)
000102  78e1              LDRB     r1,[r4,#3]  ; secondBeat
;;;155    					 {
;;;156     					 // if this is the second beat, if secondBeat == TRUE
;;;157               secondBeat = 0;         // clear secondBeat flag
;;;158                for(int i=0; i<=15; i++)
;;;159    						 {
;;;160    							// seed the running total to get a realisitic BPM at startup
;;;161                    rate[i] = IBI;                      
000104  483b              LDR      r0,|L1.500|
000106  2901              CMP      r1,#1                 ;154
000108  d107              BNE      |L1.282|
00010a  70e5              STRB     r5,[r4,#3]            ;157
00010c  2100              MOVS     r1,#0                 ;158
                  |L1.270|
00010e  6b62              LDR      r2,[r4,#0x34]  ; IBI
000110  008b              LSLS     r3,r1,#2
000112  50c2              STR      r2,[r0,r3]
000114  1c49              ADDS     r1,r1,#1
000116  290f              CMP      r1,#0xf               ;158
000118  ddf9              BLE      |L1.270|
                  |L1.282|
;;;162                  }
;;;163                }
;;;164    			
;;;165    			
;;;166    	    if(firstBeat==1)
00011a  78a1              LDRB     r1,[r4,#2]  ; firstBeat
00011c  2901              CMP      r1,#1
00011e  d03b              BEQ      |L1.408|
;;;167    				{
;;;168      				// if it's the first time we found a beat, if firstBeat == TRUE
;;;169              firstBeat = 0;                 // clear firstBeat flag
;;;170    					secondBeat = 1;  
;;;171               return;                            // IBI value is unreliable so discard it
;;;172             }   
;;;173         
;;;174              runningTotal = 0;
000120  8125              STRH     r5,[r4,#8]
;;;175        // keep a running total of the last 10 IBI values
;;;176    				 
;;;177    	#if 0			 
;;;178          
;;;179        // calculate BPM old alogrithm
;;;180        for(int i=0; i<=14; i++)
;;;181    			{               
;;;182    				// shift data in the rate array
;;;183              rate[i] = rate[i+1];              // and drop the oldest IBI value 
;;;184              runningTotal += rate[i];          // add up the 9 oldest IBI values
;;;185            }
;;;186           
;;;187        rate[15] = IBI;                          // add the latest IBI to the rate array
;;;188        runningTotal += rate[15];                // add the latest IBI to runningTotal
;;;189        runningTotal /= 16;                     // average the last 10 IBI values 
;;;190    	
;;;191    #else
;;;192    	  // calculate BPM new alogrithm find rate Max and min
;;;193    			
;;;194    			// shift data in the rate array	
;;;195    			 for(i=0; i<=14; i++)
000122  2100              MOVS     r1,#0
                  |L1.292|
000124  008a              LSLS     r2,r1,#2
;;;196    			{               	             
;;;197    				
;;;198              rate[i] = rate[i+1];              // and drop the oldest IBI value 
000126  1813              ADDS     r3,r2,r0
000128  685b              LDR      r3,[r3,#4]
00012a  5083              STR      r3,[r0,r2]
00012c  1c49              ADDS     r1,r1,#1
00012e  290e              CMP      r1,#0xe               ;195
000130  ddf8              BLE      |L1.292|
;;;199    			}	
;;;200    			rate[15]=IBI;         // update new IBI value in array
000132  6b61              LDR      r1,[r4,#0x34]  ; IBI
000134  63c1              STR      r1,[r0,#0x3c]  ; rate
;;;201    			 rate_max =rate[0];  // preset max				
000136  6801              LDR      r1,[r0,#0]  ; rate
000138  6121              STR      r1,[r4,#0x10]  ; rate_max
;;;202    			 rate_min =rate[0];	 // preset min 
00013a  6801              LDR      r1,[r0,#0]  ; rate
00013c  6161              STR      r1,[r4,#0x14]  ; rate_min
;;;203    			
;;;204    			// find max/min rate value
;;;205    			 for(i=0; i<=15; i++)
00013e  2100              MOVS     r1,#0
                  |L1.320|
000140  008a              LSLS     r2,r1,#2
;;;206    			{    
;;;207    				if(rate[i]<rate_min)
000142  5883              LDR      r3,[r0,r2]
000144  6966              LDR      r6,[r4,#0x14]  ; rate_min
000146  42b3              CMP      r3,r6
000148  da01              BGE      |L1.334|
;;;208    				{
;;;209    					rate_min=rate[i];
00014a  5883              LDR      r3,[r0,r2]
00014c  6163              STR      r3,[r4,#0x14]  ; rate_min
                  |L1.334|
;;;210    				}
;;;211            if(rate[i]>rate_max)
00014e  5883              LDR      r3,[r0,r2]
000150  6926              LDR      r6,[r4,#0x10]  ; rate_max
000152  42b3              CMP      r3,r6
000154  dd01              BLE      |L1.346|
;;;212    				{
;;;213              rate_max=rate[i];
000156  5883              LDR      r3,[r0,r2]
000158  6123              STR      r3,[r4,#0x10]  ; rate_max
                  |L1.346|
;;;214    				}	
;;;215             runningTotal += rate[i]; // sum all of IBI data				
00015a  5882              LDR      r2,[r0,r2]
00015c  8923              LDRH     r3,[r4,#8]  ; runningTotal
00015e  1c49              ADDS     r1,r1,#1
000160  18d2              ADDS     r2,r2,r3
000162  8122              STRH     r2,[r4,#8]
000164  290f              CMP      r1,#0xf               ;205
000166  ddeb              BLE      |L1.320|
;;;216    			}	
;;;217    			runningTotal = runningTotal-rate_max-rate_min;   // remove max/min vlue
000168  6921              LDR      r1,[r4,#0x10]  ; rate_max
00016a  b290              UXTH     r0,r2
00016c  1a40              SUBS     r0,r0,r1
00016e  6961              LDR      r1,[r4,#0x14]  ; rate_min
000170  1a40              SUBS     r0,r0,r1
000172  b280              UXTH     r0,r0
;;;218    			runningTotal /= 14;                     // average the last 14 IBI values 
000174  210e              MOVS     r1,#0xe
000176  f7fffffe          BL       __aeabi_uidivmod
00017a  8120              STRH     r0,[r4,#8]
00017c  4601              MOV      r1,r0
;;;219    			
;;;220    			
;;;221    			
;;;222    #endif				
;;;223    				
;;;224        BPM = 60000/runningTotal;               // how many beats can fit into a minute? that's BPM!
00017e  481e              LDR      r0,|L1.504|
000180  f7fffffe          BL       __aeabi_uidivmod
000184  63a0              STR      r0,[r4,#0x38]  ; BPM
;;;225        QS = 1;                              // set Quantified Self flag 
000186  7167              STRB     r7,[r4,#5]
                  |L1.392|
;;;226        // QS FLAG IS NOT CLEARED INSIDE THIS ISR
;;;227        }                       
;;;228    }	 
;;;229    	   //set new threshold
;;;230    		 if (Signal < thresh && Pulse == 1)
000188  8960              LDRH     r0,[r4,#0xa]  ; Signal
00018a  6aa1              LDR      r1,[r4,#0x28]  ; thresh
00018c  4288              CMP      r0,r1
00018e  da14              BGE      |L1.442|
000190  7920              LDRB     r0,[r4,#4]  ; Pulse
000192  2801              CMP      r0,#1
000194  d003              BEQ      |L1.414|
000196  e010              B        |L1.442|
                  |L1.408|
000198  70a5              STRB     r5,[r4,#2]            ;169
00019a  70e7              STRB     r7,[r4,#3]            ;170
                  |L1.412|
;;;231    			 {
;;;232    				 // when the values are going down, the beat is over 
;;;233         //   digitalWrite(blinkPin,LOW);            // turn off pin 13 LED 
;;;234    		//	nrf_gpio_pin_clear(HeartRead_LED);	 
;;;235           Pulse = 0;                         // reset the Pulse flag so we can do it again 
;;;236           Pulse_amp = P - T;                 // find pulse amplitude of the pulse wave 
;;;237           thresh = (Pulse_amp>>1) + T;                    // set thresh at 50% of the amplitude 
;;;238           P = thresh;                            // reset these for next time (peak) 
;;;239           T = thresh;                            // reset through
;;;240        } 
;;;241    		// ADC Heart Timeout 	 
;;;242       if (Pulse_Timing > ADC_Heart_Timeout)
;;;243    		 {                           // if 2.5 seconds go by without a beat 
;;;244         thresh = ADC_Heart_Threshold+15;                          // set thresh default 
;;;245         P = ADC_Heart_Threshold;                               // set P default 
;;;246         T = ADC_Heart_Threshold;                               // set T default 
;;;247         lastBeatTime = sampleCounter;          // bring the lastBeatTime up to date         
;;;248         firstBeat = 1;                      // set these to avoid noise 
;;;249         secondBeat = 0;                    // when we get the heartbeat back 
;;;250         } 
;;;251    
;;;252    		
;;;253    
;;;254    }	
00019c  bdf8              POP      {r3-r7,pc}
                  |L1.414|
00019e  7125              STRB     r5,[r4,#4]            ;235
0001a0  6a20              LDR      r0,[r4,#0x20]         ;236  ; P
0001a2  6a61              LDR      r1,[r4,#0x24]         ;236  ; T
0001a4  1a40              SUBS     r0,r0,r1              ;236
0001a6  62e0              STR      r0,[r4,#0x2c]         ;236  ; Pulse_amp
0001a8  6ae0              LDR      r0,[r4,#0x2c]         ;237  ; Pulse_amp
0001aa  6a61              LDR      r1,[r4,#0x24]         ;237  ; T
0001ac  1040              ASRS     r0,r0,#1              ;237
0001ae  1840              ADDS     r0,r0,r1              ;237
0001b0  62a0              STR      r0,[r4,#0x28]         ;237  ; thresh
0001b2  6aa0              LDR      r0,[r4,#0x28]         ;238  ; thresh
0001b4  6220              STR      r0,[r4,#0x20]         ;238  ; P
0001b6  6aa0              LDR      r0,[r4,#0x28]         ;239  ; thresh
0001b8  6260              STR      r0,[r4,#0x24]         ;239  ; T
                  |L1.442|
0001ba  6b20              LDR      r0,[r4,#0x30]         ;242  ; Pulse_Timing
0001bc  490f              LDR      r1,|L1.508|
0001be  4288              CMP      r0,r1                 ;242
0001c0  d9ec              BLS      |L1.412|
0001c2  2011              MOVS     r0,#0x11              ;244
0001c4  62a0              STR      r0,[r4,#0x28]         ;244  ; thresh
0001c6  2002              MOVS     r0,#2                 ;245
0001c8  6220              STR      r0,[r4,#0x20]         ;245  ; P
0001ca  6260              STR      r0,[r4,#0x24]         ;246  ; T
0001cc  69a0              LDR      r0,[r4,#0x18]         ;247  ; sampleCounter
0001ce  61e0              STR      r0,[r4,#0x1c]         ;247  ; lastBeatTime
0001d0  70a7              STRB     r7,[r4,#2]            ;248
0001d2  70e5              STRB     r5,[r4,#3]            ;249
0001d4  bdf8              POP      {r3-r7,pc}
;;;255    
                          ENDP

0001d6  0000              DCW      0x0000
                  |L1.472|
                          DCD      0x40007500
                  |L1.476|
                          DCD      0x40007100
                  |L1.480|
                          DCD      0x40007300
                  |L1.484|
                          DCD      0xe000e404
                  |L1.488|
                          DCD      0xe000e100
                  |L1.492|
                          DCD      ||.data||
                  |L1.496|
                          DCD      0x40007000
                  |L1.500|
                          DCD      ||.bss||
                  |L1.504|
                          DCD      0x0000ea60
                  |L1.508|
                          DCD      0x000009c4

                          AREA ||area_number.2||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.2||, ||.text||
                  adc_Heart_read PROC
;;;53     // inital ADC Heart Rate I
;;;54     void ADC_Heart_Rate_Init(uint8_t  ADC_res, uint8_t ADC_input_select, uint8_t ADC_ISR_Enable)
000000  4906              LDR      r1,|L2.28|
;;;55     	
;;;56     {
;;;57       // uint32_t err_code;
;;;58     
;;;59         // Configure ADC
;;;60     	  NRF_ADC->CONFIG     = (ADC_res                                    << ADC_CONFIG_RES_Pos)     |    // 
000002  2001              MOVS     r0,#1
000004  6008              STR      r0,[r1,#0]
000006  4806              LDR      r0,|L2.32|
                  |L2.8|
000008  6801              LDR      r1,[r0,#0]
00000a  2900              CMP      r1,#0
;;;61                               (ADC_CONFIG_INPSEL_AnalogInputOneThirdPrescaling << ADC_CONFIG_INPSEL_Pos)  |    // Analog input/3 prescaling input
;;;62                               (ADC_CONFIG_REFSEL_VBG                      << ADC_CONFIG_REFSEL_Pos)  |   // Use internal 1.2V bandgap voltage
;;;63                               (ADC_input_select                           << ADC_CONFIG_PSEL_Pos)    |
;;;64                               (ADC_CONFIG_EXTREFSEL_None                  << ADC_CONFIG_EXTREFSEL_Pos);
;;;65         NRF_ADC->EVENTS_END = 0;
00000c  d0fc              BEQ      |L2.8|
00000e  2100              MOVS     r1,#0
000010  6001              STR      r1,[r0,#0]
;;;66     	
;;;67     	
;;;68     	
;;;69     	NRF_ADC->ENABLE = 1;  
000012  4804              LDR      r0,|L2.36|
000014  6880              LDR      r0,[r0,#8]
;;;70         // Check interrupt enable  
;;;71       if(ADC_ISR_Enable)
000016  b280              UXTH     r0,r0
000018  4770              BX       lr                    ;56
;;;72             {
;;;73                 NRF_ADC->INTENSET = ADC_INTENSET_END_Msk;
;;;74                 NVIC_SetPriority(ADC_IRQn, 1);
;;;75                 NVIC_EnableIRQ(ADC_IRQn);
;;;76             }
;;;77     
;;;78     }	
;;;79     
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      0x40007000
                  |L2.32|
                          DCD      0x40007100
                  |L2.36|
                          DCD      0x40007500

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  rate
                          %        64

                          AREA ||.data||, DATA, ALIGN=2

                  HRM_Run
000000  00                DCB      0x00
                  HRM_Update
000001  00                DCB      0x00
                  firstBeat
000002  01                DCB      0x01
                  secondBeat
000003  00                DCB      0x00
                  Pulse
000004  00                DCB      0x00
                  ||QS||
000005  00                DCB      0x00
                  adc_result
000006  0000              DCW      0x0000
                  runningTotal
000008  0000              DCW      0x0000
                  Signal
00000a  0000              DCB      0x00,0x00
                  ADC_Sample_Per_Sec
                          DCD      0x00000000
                  rate_max
                          DCD      0x00000000
                  rate_min
                          DCD      0x00000000
                  sampleCounter
                          DCD      0x00000000
                  lastBeatTime
                          DCD      0x00000000
                  P
                          DCD      0x00000002
                  T
                          DCD      0x00000002
                  thresh
                          DCD      0x00000011
                  Pulse_amp
                          DCD      0x00000064
                  Pulse_Timing
                          DCD      0x00000000
                  IBI
                          DCD      0x00000258
                  BPM
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\user\\adc_heart_rate.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_adc_heart_rate_c_HRM_Run____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_adc_heart_rate_c_HRM_Run____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_adc_heart_rate_c_HRM_Run____REVSH|
#line 144
|__asm___16_adc_heart_rate_c_HRM_Run____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___16_adc_heart_rate_c_HRM_Run__nrf_delay_us|
#line 8 "..\\Include\\nrf_delay.h"
|__asm___16_adc_heart_rate_c_HRM_Run__nrf_delay_us| PROC
#line 9

loop
 SUBS R0, R0, #1
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 BNE loop
 BX LR
	ENDP

;*** End   embedded assembler ***
