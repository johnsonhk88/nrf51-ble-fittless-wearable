; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\app_button.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\app_button.d --feedback=.\obj\ak2_v1_1_0.fed --cpu=Cortex-M0 --apcs=interwork -O3 --diag_suppress=9931 -I..\Include -I..\user -I..\Include\app_common -I..\Include\ble -I..\Include\ble\ble_services -I..\Include\s110 -I..\Include\boards -I..\Include\sd_common -IC:\Johnson_project\2016_Project\BLE_Pedometer\Fittless_wearable\firmware_design\git-project\arm\RTE -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.6.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DNRF51 -DNRF51 -DDEBUG_NRF_USER -DSETUPA -DBOARD_AKII -DBLE_STACK_SUPPORT_REQD --omf_browse=.\obj\app_button.crf ..\Source\app_common\app_button.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  detection_delay_timeout_handler PROC
;;;61      */
;;;62     static void detection_delay_timeout_handler(void * p_context)
000000  b5f8              PUSH     {r3-r7,lr}
;;;63     {
;;;64         uint32_t err_code;
;;;65         uint32_t event_pins_mask;
;;;66         uint32_t current_state_pins;
;;;67         uint32_t active_pins         = 0;
;;;68     
;;;69         // Get state of pins when timer was started.
;;;70         event_pins_mask = (uint32_t)p_context;
;;;71         
;;;72         // Get current state of pins.
;;;73         err_code = app_gpiote_pins_state_get(m_gpiote_user_id, &current_state_pins);
000002  4c19              LDR      r4,|L1.104|
000004  4605              MOV      r5,r0                 ;70
000006  4669              MOV      r1,sp
000008  7860              LDRB     r0,[r4,#1]  ; m_gpiote_user_id
00000a  f7fffffe          BL       app_gpiote_pins_state_get
;;;74         if (err_code != NRF_SUCCESS)
00000e  2800              CMP      r0,#0
000010  d129              BNE      |L1.102|
;;;75         {
;;;76             return;
;;;77         }
;;;78     
;;;79         active_pins      = current_state_pins & m_active_high_states_mask;
000012  9900              LDR      r1,[sp,#0]
000014  68e0              LDR      r0,[r4,#0xc]  ; m_active_high_states_mask
000016  460b              MOV      r3,r1
000018  4001              ANDS     r1,r1,r0
;;;80         active_pins     |= (~current_state_pins & m_active_low_states_mask);
00001a  68a0              LDR      r0,[r4,#8]  ; m_active_low_states_mask
00001c  462e              MOV      r6,r5
00001e  4398              BICS     r0,r0,r3
000020  4308              ORRS     r0,r0,r1
;;;81         event_pins_mask &= active_pins;
000022  4006              ANDS     r6,r6,r0
;;;82     
;;;83         // Check if any event generating pins are still active.
;;;84         if (event_pins_mask != 0)
000024  d01f              BEQ      |L1.102|
;;;85         {
;;;86             uint8_t i;
;;;87             
;;;88             // Pushed button(s) detected, execute button handler(s).
;;;89             for (i = 0; i < m_button_count; i++)
000026  2500              MOVS     r5,#0
000028  e01a              B        |L1.96|
                  |L1.42|
;;;90             {
;;;91                 app_button_cfg_t * p_btn = &mp_buttons[i];
00002a  6861              LDR      r1,[r4,#4]  ; mp_buttons
00002c  00e8              LSLS     r0,r5,#3              ;89
00002e  1841              ADDS     r1,r0,r1
;;;92                 
;;;93                 if (((event_pins_mask & (1 << p_btn->pin_no)) != 0) && (p_btn->button_handler != NULL))
000030  7808              LDRB     r0,[r1,#0]
000032  2201              MOVS     r2,#1
000034  4082              LSLS     r2,r2,r0
000036  4232              TST      r2,r6
000038  d010              BEQ      |L1.92|
00003a  684a              LDR      r2,[r1,#4]
00003c  2a00              CMP      r2,#0
00003e  d00d              BEQ      |L1.92|
000040  6963              LDR      r3,[r4,#0x14]  ; m_evt_schedule_func
000042  2b00              CMP      r3,#0
000044  d009              BEQ      |L1.90|
000046  4601              MOV      r1,r0
000048  4610              MOV      r0,r2
00004a  4798              BLX      r3
00004c  2800              CMP      r0,#0
00004e  d005              BEQ      |L1.92|
000050  a206              ADR      r2,|L1.108|
000052  2129              MOVS     r1,#0x29
000054  f7fffffe          BL       app_error_handler
000058  e000              B        |L1.92|
                  |L1.90|
00005a  4790              BLX      r2
                  |L1.92|
00005c  1c6d              ADDS     r5,r5,#1
00005e  b2ed              UXTB     r5,r5                 ;89
                  |L1.96|
000060  7820              LDRB     r0,[r4,#0]            ;89  ; m_button_count
000062  4285              CMP      r5,r0                 ;89
000064  d3e1              BCC      |L1.42|
                  |L1.102|
;;;94                 {
;;;95                     button_handler_execute(p_btn);
;;;96                 }
;;;97             }
;;;98         }
;;;99     }
000066  bdf8              POP      {r3-r7,pc}
;;;100    
                          ENDP

                  |L1.104|
                          DCD      ||.data||
                  |L1.108|
00006c  2e2e5c53          DCB      "..\\Source\\app_common\\app_button.c",0
000070  6f757263
000074  655c6170
000078  705f636f
00007c  6d6d6f6e
000080  5c617070
000084  5f627574
000088  746f6e2e
00008c  6300    
00008e  00                DCB      0
00008f  00                DCB      0

                          AREA ||area_number.2||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.2||, ||.text||
                  gpiote_event_handler PROC
;;;61      */
;;;62     static void detection_delay_timeout_handler(void * p_context)
000000  b570              PUSH     {r4-r6,lr}
;;;63     {
;;;64         uint32_t err_code;
;;;65         uint32_t event_pins_mask;
;;;66         uint32_t current_state_pins;
;;;67         uint32_t active_pins         = 0;
;;;68     
;;;69         // Get state of pins when timer was started.
;;;70         event_pins_mask = (uint32_t)p_context;
;;;71         
;;;72         // Get current state of pins.
;;;73         err_code = app_gpiote_pins_state_get(m_gpiote_user_id, &current_state_pins);
000002  4d07              LDR      r5,|L2.32|
000004  4604              MOV      r4,r0                 ;70
000006  460e              MOV      r6,r1
000008  69a8              LDR      r0,[r5,#0x18]  ; m_detection_delay_timer_id
00000a  f7fffffe          BL       app_timer_stop
;;;74         if (err_code != NRF_SUCCESS)
00000e  2800              CMP      r0,#0
000010  d105              BNE      |L2.30|
;;;75         {
;;;76             return;
;;;77         }
;;;78     
;;;79         active_pins      = current_state_pins & m_active_high_states_mask;
000012  4334              ORRS     r4,r4,r6
000014  4622              MOV      r2,r4
000016  6929              LDR      r1,[r5,#0x10]  ; m_detection_delay
000018  69a8              LDR      r0,[r5,#0x18]  ; m_detection_delay_timer_id
;;;80         active_pins     |= (~current_state_pins & m_active_low_states_mask);
00001a  f7fffffe          BL       app_timer_start
                  |L2.30|
00001e  bd70              POP      {r4-r6,pc}
;;;81         event_pins_mask &= active_pins;
;;;82     
;;;83         // Check if any event generating pins are still active.
;;;84         if (event_pins_mask != 0)
;;;85         {
;;;86             uint8_t i;
;;;87             
;;;88             // Pushed button(s) detected, execute button handler(s).
;;;89             for (i = 0; i < m_button_count; i++)
;;;90             {
;;;91                 app_button_cfg_t * p_btn = &mp_buttons[i];
;;;92                 
;;;93                 if (((event_pins_mask & (1 << p_btn->pin_no)) != 0) && (p_btn->button_handler != NULL))
;;;94                 {
;;;95                     button_handler_execute(p_btn);
;;;96                 }
;;;97             }
;;;98         }
;;;99     }
;;;100    
                          ENDP

                  |L2.32|
                          DCD      ||.data||

                          AREA ||area_number.3||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.3||, ||.text||
                  app_button_init PROC
;;;61      */
;;;62     static void detection_delay_timeout_handler(void * p_context)
000000  b5f8              PUSH     {r3-r7,lr}
;;;63     {
;;;64         uint32_t err_code;
;;;65         uint32_t event_pins_mask;
;;;66         uint32_t current_state_pins;
;;;67         uint32_t active_pins         = 0;
;;;68     
;;;69         // Get state of pins when timer was started.
;;;70         event_pins_mask = (uint32_t)p_context;
;;;71         
;;;72         // Get current state of pins.
;;;73         err_code = app_gpiote_pins_state_get(m_gpiote_user_id, &current_state_pins);
000002  460c              MOV      r4,r1
000004  2a05              CMP      r2,#5                 ;70
000006  d201              BCS      |L3.12|
000008  2007              MOVS     r0,#7
                  |L3.10|
00000a  bdf8              POP      {r3-r7,pc}
                  |L3.12|
00000c  4d1b              LDR      r5,|L3.124|
;;;74         if (err_code != NRF_SUCCESS)
00000e  2100              MOVS     r1,#0
000010  6068              STR      r0,[r5,#4]  ; mp_buttons
;;;75         {
;;;76             return;
;;;77         }
;;;78     
;;;79         active_pins      = current_state_pins & m_active_high_states_mask;
000012  462e              MOV      r6,r5
000014  702c              STRB     r4,[r5,#0]
000016  360c              ADDS     r6,r6,#0xc
000018  c60e              STM      r6!,{r1-r3}
;;;80         active_pins     |= (~current_state_pins & m_active_low_states_mask);
00001a  460a              MOV      r2,r1
00001c  60a9              STR      r1,[r5,#8]  ; m_active_low_states_mask
00001e  e016              B        |L3.78|
                  |L3.32|
000020  00e3              LSLS     r3,r4,#3
;;;81         event_pins_mask &= active_pins;
000022  181b              ADDS     r3,r3,r0
;;;82     
;;;83         // Check if any event generating pins are still active.
;;;84         if (event_pins_mask != 0)
000024  781e              LDRB     r6,[r3,#0]
;;;85         {
;;;86             uint8_t i;
;;;87             
;;;88             // Pushed button(s) detected, execute button handler(s).
;;;89             for (i = 0; i < m_button_count; i++)
000026  789d              LDRB     r5,[r3,#2]
000028  4f15              LDR      r7,|L3.128|
;;;90             {
;;;91                 app_button_cfg_t * p_btn = &mp_buttons[i];
00002a  00ad              LSLS     r5,r5,#2
00002c  00b6              LSLS     r6,r6,#2              ;89
00002e  19f6              ADDS     r6,r6,r7
;;;92                 
;;;93                 if (((event_pins_mask & (1 << p_btn->pin_no)) != 0) && (p_btn->button_handler != NULL))
000030  6035              STR      r5,[r6,#0]
000032  785d              LDRB     r5,[r3,#1]
000034  2d00              CMP      r5,#0
000036  d001              BEQ      |L3.60|
000038  2701              MOVS     r7,#1
00003a  e000              B        |L3.62|
                  |L3.60|
00003c  2700              MOVS     r7,#0
                  |L3.62|
00003e  781e              LDRB     r6,[r3,#0]
000040  40b7              LSLS     r7,r7,r6
000042  4339              ORRS     r1,r1,r7
000044  2d00              CMP      r5,#0
000046  d017              BEQ      |L3.120|
000048  2300              MOVS     r3,#0
                  |L3.74|
00004a  40b3              LSLS     r3,r3,r6
00004c  431a              ORRS     r2,r2,r3
                  |L3.78|
00004e  4623              MOV      r3,r4
000050  1e64              SUBS     r4,r4,#1
000052  b2e4              UXTB     r4,r4
000054  2b00              CMP      r3,#0
000056  d1e3              BNE      |L3.32|
000058  4808              LDR      r0,|L3.124|
00005a  4b0a              LDR      r3,|L3.132|
00005c  6082              STR      r2,[r0,#8]  ; m_active_low_states_mask
00005e  60c1              STR      r1,[r0,#0xc]          ;89  ; m_active_high_states_mask
000060  1c40              ADDS     r0,r0,#1              ;89
000062  f7fffffe          BL       app_gpiote_user_register
;;;94                 {
;;;95                     button_handler_execute(p_btn);
;;;96                 }
;;;97             }
;;;98         }
;;;99     }
000066  2800              CMP      r0,#0
000068  d1cf              BNE      |L3.10|
00006a  4804              LDR      r0,|L3.124|
00006c  4a06              LDR      r2,|L3.136|
00006e  2100              MOVS     r1,#0
000070  3018              ADDS     r0,r0,#0x18
000072  f7fffffe          BL       app_timer_create
000076  bdf8              POP      {r3-r7,pc}
                  |L3.120|
000078  2301              MOVS     r3,#1
00007a  e7e6              B        |L3.74|
;;;100    
                          ENDP

                  |L3.124|
                          DCD      ||.data||
                  |L3.128|
                          DCD      0x50000700
                  |L3.132|
                          DCD      gpiote_event_handler
                  |L3.136|
                          DCD      detection_delay_timeout_handler

                          AREA ||area_number.4||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.4||, ||.text||
                  app_button_enable PROC
;;;61      */
;;;62     static void detection_delay_timeout_handler(void * p_context)
000000  b510              PUSH     {r4,lr}
;;;63     {
;;;64         uint32_t err_code;
;;;65         uint32_t event_pins_mask;
;;;66         uint32_t current_state_pins;
;;;67         uint32_t active_pins         = 0;
;;;68     
;;;69         // Get state of pins when timer was started.
;;;70         event_pins_mask = (uint32_t)p_context;
;;;71         
;;;72         // Get current state of pins.
;;;73         err_code = app_gpiote_pins_state_get(m_gpiote_user_id, &current_state_pins);
000002  4805              LDR      r0,|L4.24|
000004  6841              LDR      r1,[r0,#4]            ;70  ; mp_buttons
000006  2900              CMP      r1,#0
000008  d003              BEQ      |L4.18|
00000a  7840              LDRB     r0,[r0,#1]  ; m_gpiote_user_id
00000c  f7fffffe          BL       app_gpiote_user_enable
;;;74         if (err_code != NRF_SUCCESS)
000010  bd10              POP      {r4,pc}
                  |L4.18|
;;;75         {
;;;76             return;
;;;77         }
;;;78     
;;;79         active_pins      = current_state_pins & m_active_high_states_mask;
000012  2008              MOVS     r0,#8
000014  bd10              POP      {r4,pc}
;;;80         active_pins     |= (~current_state_pins & m_active_low_states_mask);
;;;81         event_pins_mask &= active_pins;
;;;82     
;;;83         // Check if any event generating pins are still active.
;;;84         if (event_pins_mask != 0)
;;;85         {
;;;86             uint8_t i;
;;;87             
;;;88             // Pushed button(s) detected, execute button handler(s).
;;;89             for (i = 0; i < m_button_count; i++)
;;;90             {
;;;91                 app_button_cfg_t * p_btn = &mp_buttons[i];
;;;92                 
;;;93                 if (((event_pins_mask & (1 << p_btn->pin_no)) != 0) && (p_btn->button_handler != NULL))
;;;94                 {
;;;95                     button_handler_execute(p_btn);
;;;96                 }
;;;97             }
;;;98         }
;;;99     }
;;;100    
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      ||.data||

                          AREA ||area_number.5||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.5||, ||.text||
                  app_button_disable PROC
;;;61      */
;;;62     static void detection_delay_timeout_handler(void * p_context)
000000  b510              PUSH     {r4,lr}
;;;63     {
;;;64         uint32_t err_code;
;;;65         uint32_t event_pins_mask;
;;;66         uint32_t current_state_pins;
;;;67         uint32_t active_pins         = 0;
;;;68     
;;;69         // Get state of pins when timer was started.
;;;70         event_pins_mask = (uint32_t)p_context;
;;;71         
;;;72         // Get current state of pins.
;;;73         err_code = app_gpiote_pins_state_get(m_gpiote_user_id, &current_state_pins);
000002  4c07              LDR      r4,|L5.32|
000004  6860              LDR      r0,[r4,#4]            ;70  ; mp_buttons
000006  2800              CMP      r0,#0
000008  d008              BEQ      |L5.28|
00000a  7860              LDRB     r0,[r4,#1]  ; m_gpiote_user_id
00000c  f7fffffe          BL       app_gpiote_user_disable
;;;74         if (err_code != NRF_SUCCESS)
000010  2800              CMP      r0,#0
;;;75         {
;;;76             return;
;;;77         }
;;;78     
;;;79         active_pins      = current_state_pins & m_active_high_states_mask;
000012  d102              BNE      |L5.26|
000014  69a0              LDR      r0,[r4,#0x18]  ; m_detection_delay_timer_id
000016  f7fffffe          BL       app_timer_stop
                  |L5.26|
;;;80         active_pins     |= (~current_state_pins & m_active_low_states_mask);
00001a  bd10              POP      {r4,pc}
                  |L5.28|
00001c  2008              MOVS     r0,#8
00001e  bd10              POP      {r4,pc}
;;;81         event_pins_mask &= active_pins;
;;;82     
;;;83         // Check if any event generating pins are still active.
;;;84         if (event_pins_mask != 0)
;;;85         {
;;;86             uint8_t i;
;;;87             
;;;88             // Pushed button(s) detected, execute button handler(s).
;;;89             for (i = 0; i < m_button_count; i++)
;;;90             {
;;;91                 app_button_cfg_t * p_btn = &mp_buttons[i];
;;;92                 
;;;93                 if (((event_pins_mask & (1 << p_btn->pin_no)) != 0) && (p_btn->button_handler != NULL))
;;;94                 {
;;;95                     button_handler_execute(p_btn);
;;;96                 }
;;;97             }
;;;98         }
;;;99     }
;;;100    
                          ENDP

                  |L5.32|
                          DCD      ||.data||

                          AREA ||area_number.6||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.6||, ||.text||
                  app_button_is_pushed PROC
;;;61      */
;;;62     static void detection_delay_timeout_handler(void * p_context)
000000  b5f8              PUSH     {r3-r7,lr}
;;;63     {
;;;64         uint32_t err_code;
;;;65         uint32_t event_pins_mask;
;;;66         uint32_t current_state_pins;
;;;67         uint32_t active_pins         = 0;
;;;68     
;;;69         // Get state of pins when timer was started.
;;;70         event_pins_mask = (uint32_t)p_context;
;;;71         
;;;72         // Get current state of pins.
;;;73         err_code = app_gpiote_pins_state_get(m_gpiote_user_id, &current_state_pins);
000002  4c0e              LDR      r4,|L6.60|
000004  4606              MOV      r6,r0                 ;70
000006  6860              LDR      r0,[r4,#4]  ; mp_buttons
000008  460d              MOV      r5,r1
00000a  2800              CMP      r0,#0
00000c  d013              BEQ      |L6.54|
;;;74         if (err_code != NRF_SUCCESS)
00000e  4669              MOV      r1,sp
000010  7860              LDRB     r0,[r4,#1]  ; m_gpiote_user_id
;;;75         {
;;;76             return;
;;;77         }
;;;78     
;;;79         active_pins      = current_state_pins & m_active_high_states_mask;
000012  f7fffffe          BL       app_gpiote_pins_state_get
000016  2800              CMP      r0,#0
000018  d10c              BNE      |L6.52|
;;;80         active_pins     |= (~current_state_pins & m_active_low_states_mask);
00001a  2201              MOVS     r2,#1
00001c  9800              LDR      r0,[sp,#0]
00001e  40b2              LSLS     r2,r2,r6
000020  4202              TST      r2,r0
;;;81         event_pins_mask &= active_pins;
000022  d101              BNE      |L6.40|
;;;82     
;;;83         // Check if any event generating pins are still active.
;;;84         if (event_pins_mask != 0)
000024  68a0              LDR      r0,[r4,#8]  ; m_active_low_states_mask
;;;85         {
;;;86             uint8_t i;
;;;87             
;;;88             // Pushed button(s) detected, execute button handler(s).
;;;89             for (i = 0; i < m_button_count; i++)
000026  e000              B        |L6.42|
                  |L6.40|
000028  68e0              LDR      r0,[r4,#0xc]  ; m_active_high_states_mask
                  |L6.42|
;;;90             {
;;;91                 app_button_cfg_t * p_btn = &mp_buttons[i];
00002a  4010              ANDS     r0,r0,r2
00002c  d000              BEQ      |L6.48|
00002e  2001              MOVS     r0,#1
                  |L6.48|
;;;92                 
;;;93                 if (((event_pins_mask & (1 << p_btn->pin_no)) != 0) && (p_btn->button_handler != NULL))
000030  7028              STRB     r0,[r5,#0]
000032  2000              MOVS     r0,#0
                  |L6.52|
000034  bdf8              POP      {r3-r7,pc}
                  |L6.54|
000036  2008              MOVS     r0,#8
000038  bdf8              POP      {r3-r7,pc}
;;;94                 {
;;;95                     button_handler_execute(p_btn);
;;;96                 }
;;;97             }
;;;98         }
;;;99     }
;;;100    
                          ENDP

00003a  0000              DCW      0x0000
                  |L6.60|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  m_button_count
000000  00                DCB      0x00
                  m_gpiote_user_id
000001  000000            DCB      0x00,0x00,0x00
                  mp_buttons
                          DCD      0x00000000
                  m_active_low_states_mask
                          DCD      0x00000000
                  m_active_high_states_mask
                          DCD      0x00000000
                  m_detection_delay
                          DCD      0x00000000
                  m_evt_schedule_func
                          DCD      0x00000000
                  m_detection_delay_timer_id
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Source\\app_common\\app_button.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_app_button_c_bd9cca92____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_app_button_c_bd9cca92____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_app_button_c_bd9cca92____REVSH|
#line 144
|__asm___12_app_button_c_bd9cca92____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
