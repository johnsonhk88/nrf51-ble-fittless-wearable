; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\ble_conn_params.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\ble_conn_params.d --feedback=.\obj\ak2_v1_1_0.fed --cpu=Cortex-M0 --apcs=interwork -O3 --diag_suppress=9931 -I..\Include -I..\user -I..\Include\app_common -I..\Include\ble -I..\Include\ble\ble_services -I..\Include\s110 -I..\Include\boards -I..\Include\sd_common -IC:\Johnson_project\2016_Project\BLE_Pedometer\Fittless_wearable\firmware_design\git-project\arm\RTE -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.6.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DNRF51 -DNRF51 -DDEBUG_NRF_USER -DSETUPA -DBOARD_AKII -DBLE_STACK_SUPPORT_REQD --omf_browse=.\obj\ble_conn_params.crf ..\Source\ble\ble_conn_params.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  update_timeout_handler PROC
;;;50     
;;;51     static void update_timeout_handler(void * p_context)
000000  b538              PUSH     {r3-r5,lr}
;;;52     {
;;;53         UNUSED_PARAMETER(p_context);
;;;54     
;;;55         if (m_conn_handle != BLE_CONN_HANDLE_INVALID)
000002  4965              LDR      r1,|L1.408|
000004  4a65              LDR      r2,|L1.412|
000006  8848              LDRH     r0,[r1,#2]  ; m_conn_handle
000008  4290              CMP      r0,r2
00000a  d00f              BEQ      |L1.44|
;;;56         {
;;;57             // Check if we have reached the maximum number of attempts
;;;58             m_update_count++;
00000c  784a              LDRB     r2,[r1,#1]  ; m_update_count
;;;59             if (m_update_count <= m_conn_params_config.max_conn_params_update_count)
00000e  4c64              LDR      r4,|L1.416|
000010  1c52              ADDS     r2,r2,#1              ;58
000012  b2d2              UXTB     r2,r2                 ;58
000014  704a              STRB     r2,[r1,#1]            ;58
000016  7b23              LDRB     r3,[r4,#0xc]  ; m_conn_params_config
000018  4293              CMP      r3,r2
00001a  d308              BCC      |L1.46|
;;;60             {
;;;61                 uint32_t err_code;
;;;62                 
;;;63                 // Parameters are not ok, send connection parameters update request.
;;;64                 err_code = sd_ble_gap_conn_param_update(m_conn_handle, &m_preferred_conn_params);
00001c  3108              ADDS     r1,r1,#8
00001e  df75              SVC      #0x75
;;;65                 if ((err_code != NRF_SUCCESS) && (m_conn_params_config.error_handler != NULL))
000020  2800              CMP      r0,#0
000022  d003              BEQ      |L1.44|
000024  69a1              LDR      r1,[r4,#0x18]  ; m_conn_params_config
000026  2900              CMP      r1,#0
000028  d000              BEQ      |L1.44|
;;;66                 {
;;;67                     m_conn_params_config.error_handler(err_code);
00002a  4788              BLX      r1
                  |L1.44|
;;;68                 }
;;;69             }
;;;70             else
;;;71             {
;;;72                 m_update_count = 0;
;;;73                 
;;;74                 // Negotiation failed, disconnect automatically if this has been configured
;;;75                 if (m_conn_params_config.disconnect_on_fail)
;;;76                 {
;;;77                     uint32_t err_code;
;;;78                     
;;;79                     err_code = sd_ble_gap_disconnect(m_conn_handle, BLE_HCI_CONN_INTERVAL_UNACCEPTABLE);
;;;80                     if ((err_code != NRF_SUCCESS) && (m_conn_params_config.error_handler != NULL))
;;;81                     {
;;;82                         m_conn_params_config.error_handler(err_code);
;;;83                     }
;;;84                 }
;;;85                 
;;;86                 // Notify the application that the procedure has failed
;;;87                 if (m_conn_params_config.evt_handler != NULL)
;;;88                 {
;;;89                     ble_conn_params_evt_t evt;
;;;90                     
;;;91                     evt.evt_type = BLE_CONN_PARAMS_EVT_FAILED;
;;;92                     m_conn_params_config.evt_handler(&evt);
;;;93                 }
;;;94             }
;;;95         }
;;;96     }
00002c  bd38              POP      {r3-r5,pc}
                  |L1.46|
00002e  2500              MOVS     r5,#0                 ;72
000030  704d              STRB     r5,[r1,#1]            ;72
000032  7c21              LDRB     r1,[r4,#0x10]         ;75  ; m_conn_params_config
000034  2900              CMP      r1,#0                 ;75
000036  d007              BEQ      |L1.72|
000038  213b              MOVS     r1,#0x3b              ;79
00003a  df76              SVC      #0x76                 ;79
00003c  2800              CMP      r0,#0                 ;80
00003e  d003              BEQ      |L1.72|
000040  69a1              LDR      r1,[r4,#0x18]         ;80  ; m_conn_params_config
000042  2900              CMP      r1,#0                 ;80
000044  d000              BEQ      |L1.72|
000046  4788              BLX      r1                    ;82
                  |L1.72|
000048  6961              LDR      r1,[r4,#0x14]         ;87  ; m_conn_params_config
00004a  2900              CMP      r1,#0                 ;87
00004c  d0ee              BEQ      |L1.44|
00004e  4668              MOV      r0,sp                 ;91
000050  7005              STRB     r5,[r0,#0]            ;91
000052  4788              BLX      r1                    ;92
000054  bd38              POP      {r3-r5,pc}
;;;97     
                          ENDP

                  ble_conn_params_init PROC
;;;98     
;;;99     uint32_t ble_conn_params_init(const ble_conn_params_init_t * p_init)
000056  b570              PUSH     {r4-r6,lr}
;;;100    {
000058  4605              MOV      r5,r0
;;;101        uint32_t err_code;
;;;102        
;;;103        m_conn_params_config = *p_init;
00005a  4601              MOV      r1,r0
00005c  221c              MOVS     r2,#0x1c
00005e  4850              LDR      r0,|L1.416|
000060  f7fffffe          BL       __aeabi_memcpy4
;;;104        m_change_param = false;
000064  4c4c              LDR      r4,|L1.408|
000066  2600              MOVS     r6,#0
000068  7026              STRB     r6,[r4,#0]
;;;105        if (p_init->p_conn_params != NULL)
00006a  6829              LDR      r1,[r5,#0]
00006c  2900              CMP      r1,#0
00006e  d007              BEQ      |L1.128|
;;;106        {
;;;107            m_preferred_conn_params = *p_init->p_conn_params;
000070  2208              MOVS     r2,#8
000072  18a0              ADDS     r0,r4,r2
000074  f7fffffe          BL       __aeabi_memcpy
;;;108            
;;;109            // Set the connection params in stack
;;;110            err_code = sd_ble_gap_ppcp_set(&m_preferred_conn_params);
000078  4620              MOV      r0,r4
00007a  3008              ADDS     r0,r0,#8
00007c  df7a              SVC      #0x7a
;;;111            if (err_code != NRF_SUCCESS)
00007e  e002              B        |L1.134|
                  |L1.128|
;;;112            {
;;;113                return err_code;
;;;114            }
;;;115        }
;;;116        else
;;;117        {
;;;118            // Fetch the connection params from stack
;;;119            err_code = sd_ble_gap_ppcp_get(&m_preferred_conn_params);
000080  4845              LDR      r0,|L1.408|
000082  3008              ADDS     r0,r0,#8
000084  df7b              SVC      #0x7b
                  |L1.134|
;;;120            if (err_code != NRF_SUCCESS)
000086  2800              CMP      r0,#0
000088  d108              BNE      |L1.156|
;;;121            {
;;;122                return err_code;
;;;123            }
;;;124        }
;;;125    
;;;126        m_conn_handle  = BLE_CONN_HANDLE_INVALID;
00008a  1e40              SUBS     r0,r0,#1
00008c  8060              STRH     r0,[r4,#2]
;;;127        m_update_count = 0;
;;;128        
;;;129        return app_timer_create(&m_conn_params_timer_id,
00008e  4842              LDR      r0,|L1.408|
000090  7066              STRB     r6,[r4,#1]            ;127
000092  4a44              LDR      r2,|L1.420|
000094  2100              MOVS     r1,#0
000096  1d00              ADDS     r0,r0,#4
000098  f7fffffe          BL       app_timer_create
                  |L1.156|
;;;130                                APP_TIMER_MODE_SINGLE_SHOT,
;;;131                                update_timeout_handler);
;;;132    }
00009c  bd70              POP      {r4-r6,pc}
;;;133    
                          ENDP

                  conn_params_negotiation PROC
;;;140    
;;;141    static void conn_params_negotiation(void)
00009e  b5f8              PUSH     {r3-r7,lr}
;;;142    {
;;;143        // Start negotiation if the received connection parameters are not acceptable
;;;144        if (!is_conn_params_ok(&m_current_conn_params))
0000a0  483d              LDR      r0,|L1.408|
0000a2  3010              ADDS     r0,r0,#0x10
0000a4  f7fffffe          BL       is_conn_params_ok
0000a8  2600              MOVS     r6,#0
;;;145        {
;;;146            uint32_t err_code;
;;;147            uint32_t timeout_ticks;
;;;148            
;;;149            if (m_change_param)
0000aa  4d3b              LDR      r5,|L1.408|
;;;150            {
;;;151                // Notify the application that the procedure has failed
;;;152                if (m_conn_params_config.evt_handler != NULL)
0000ac  4c3c              LDR      r4,|L1.416|
0000ae  2800              CMP      r0,#0                 ;144
0000b0  d007              BEQ      |L1.194|
;;;153                {
;;;154                    ble_conn_params_evt_t evt;
;;;155                    
;;;156                    evt.evt_type = BLE_CONN_PARAMS_EVT_FAILED;
;;;157                    m_conn_params_config.evt_handler(&evt);
;;;158                }
;;;159            }
;;;160            else
;;;161            {
;;;162                if (m_update_count == 0)
;;;163                {
;;;164                    // First connection parameter update
;;;165                    timeout_ticks = m_conn_params_config.first_conn_params_update_delay;
;;;166                }
;;;167                else
;;;168                {
;;;169                    timeout_ticks = m_conn_params_config.next_conn_params_update_delay;
;;;170                }
;;;171    
;;;172                err_code = app_timer_start(m_conn_params_timer_id, timeout_ticks, NULL);
;;;173                if ((err_code != NRF_SUCCESS) && (m_conn_params_config.error_handler != NULL))
;;;174                {
;;;175                    m_conn_params_config.error_handler(err_code);
;;;176                }
;;;177            }
;;;178        }
;;;179        else
;;;180        {
;;;181            // Notify the application that the procedure has succeded
;;;182            if (m_conn_params_config.evt_handler != NULL)
0000b2  6961              LDR      r1,[r4,#0x14]  ; m_conn_params_config
0000b4  2900              CMP      r1,#0
0000b6  d01b              BEQ      |L1.240|
;;;183            {
;;;184                ble_conn_params_evt_t evt;
;;;185                
;;;186                evt.evt_type = BLE_CONN_PARAMS_EVT_SUCCEEDED;
0000b8  2001              MOVS     r0,#1
0000ba  466a              MOV      r2,sp
0000bc  7010              STRB     r0,[r2,#0]
;;;187                m_conn_params_config.evt_handler(&evt);
0000be  4668              MOV      r0,sp
;;;188            }
0000c0  e015              B        |L1.238|
                  |L1.194|
0000c2  7828              LDRB     r0,[r5,#0]            ;149  ; m_change_param
0000c4  2800              CMP      r0,#0                 ;149
0000c6  d005              BEQ      |L1.212|
0000c8  6961              LDR      r1,[r4,#0x14]         ;152  ; m_conn_params_config
0000ca  2900              CMP      r1,#0                 ;152
0000cc  d010              BEQ      |L1.240|
0000ce  4668              MOV      r0,sp                 ;156
0000d0  7006              STRB     r6,[r0,#0]            ;156
0000d2  e00c              B        |L1.238|
                  |L1.212|
0000d4  7868              LDRB     r0,[r5,#1]            ;162  ; m_update_count
0000d6  2800              CMP      r0,#0                 ;162
0000d8  d00c              BEQ      |L1.244|
0000da  68a1              LDR      r1,[r4,#8]            ;169  ; m_conn_params_config
                  |L1.220|
0000dc  2200              MOVS     r2,#0                 ;172
0000de  6868              LDR      r0,[r5,#4]            ;172  ; m_conn_params_timer_id
0000e0  f7fffffe          BL       app_timer_start
0000e4  2800              CMP      r0,#0                 ;173
0000e6  d003              BEQ      |L1.240|
0000e8  69a1              LDR      r1,[r4,#0x18]         ;173  ; m_conn_params_config
0000ea  2900              CMP      r1,#0                 ;173
0000ec  d000              BEQ      |L1.240|
                  |L1.238|
0000ee  4788              BLX      r1                    ;175
                  |L1.240|
;;;189        }
;;;190        m_change_param = false;
0000f0  702e              STRB     r6,[r5,#0]
;;;191    }
0000f2  bdf8              POP      {r3-r7,pc}
                  |L1.244|
0000f4  6861              LDR      r1,[r4,#4]            ;165  ; m_conn_params_config
0000f6  e7f1              B        |L1.220|
;;;192    
                          ENDP

                  ble_conn_params_on_ble_evt PROC
;;;266    
;;;267    void ble_conn_params_on_ble_evt(ble_evt_t * p_ble_evt)
0000f8  b5f8              PUSH     {r3-r7,lr}
0000fa  4c29              LDR      r4,|L1.416|
;;;268    {
;;;269        switch (p_ble_evt->header.evt_id)
0000fc  8802              LDRH     r2,[r0,#0]
0000fe  2700              MOVS     r7,#0
000100  4d25              LDR      r5,|L1.408|
000102  89e6              LDRH     r6,[r4,#0xe]
000104  2a10              CMP      r2,#0x10
000106  d018              BEQ      |L1.314|
000108  4629              MOV      r1,r5                 ;268
00010a  6849              LDR      r1,[r1,#4]            ;268
00010c  2a11              CMP      r2,#0x11
00010e  d021              BEQ      |L1.340|
000110  2a12              CMP      r2,#0x12
000112  d02d              BEQ      |L1.368|
000114  2a50              CMP      r2,#0x50
000116  d10f              BNE      |L1.312|
000118  88c2              LDRH     r2,[r0,#6]
00011a  1d80              ADDS     r0,r0,#6
00011c  42b2              CMP      r2,r6
00011e  d10b              BNE      |L1.312|
000120  8b02              LDRH     r2,[r0,#0x18]
000122  2a02              CMP      r2,#2
000124  d108              BNE      |L1.312|
000126  7ec2              LDRB     r2,[r0,#0x1b]
000128  7e83              LDRB     r3,[r0,#0x1a]
00012a  0210              LSLS     r0,r2,#8
00012c  4318              ORRS     r0,r0,r3
00012e  07c0              LSLS     r0,r0,#31
000130  0fc0              LSRS     r0,r0,#31
000132  d013              BEQ      |L1.348|
                  |L1.308|
000134  f7fffffe          BL       conn_params_negotiation
                  |L1.312|
;;;270        {
;;;271            case BLE_GAP_EVT_CONNECTED:
;;;272                on_connect(p_ble_evt);
;;;273                break;
;;;274                
;;;275            case BLE_GAP_EVT_DISCONNECTED:
;;;276                on_disconnect(p_ble_evt);
;;;277                break;
;;;278                
;;;279            case BLE_GATTS_EVT_WRITE:
;;;280                on_write(p_ble_evt);
;;;281                break;
;;;282                
;;;283            case BLE_GAP_EVT_CONN_PARAM_UPDATE:
;;;284                on_conn_params_update(p_ble_evt);
;;;285                break;
;;;286                
;;;287            default:
;;;288                // No implementation needed.
;;;289               break;
;;;290        }
;;;291    }
000138  bdf8              POP      {r3-r7,pc}
                  |L1.314|
00013a  8881              LDRH     r1,[r0,#4]
00013c  8069              STRH     r1,[r5,#2]
00013e  4601              MOV      r1,r0
000140  4815              LDR      r0,|L1.408|
000142  2208              MOVS     r2,#8
000144  310e              ADDS     r1,r1,#0xe
000146  3010              ADDS     r0,r0,#0x10
000148  f7fffffe          BL       __aeabi_memcpy
00014c  706f              STRB     r7,[r5,#1]
00014e  2e00              CMP      r6,#0
000150  d0f0              BEQ      |L1.308|
                  |L1.338|
000152  bdf8              POP      {r3-r7,pc}
                  |L1.340|
000154  2000              MOVS     r0,#0
000156  43c0              MVNS     r0,r0
000158  8068              STRH     r0,[r5,#2]
00015a  706f              STRB     r7,[r5,#1]
                  |L1.348|
00015c  4608              MOV      r0,r1
00015e  f7fffffe          BL       app_timer_stop
000162  2800              CMP      r0,#0
000164  d0f5              BEQ      |L1.338|
000166  69a1              LDR      r1,[r4,#0x18]  ; m_conn_params_config
000168  2900              CMP      r1,#0
00016a  d0f2              BEQ      |L1.338|
00016c  4788              BLX      r1
00016e  bdf8              POP      {r3-r7,pc}
                  |L1.368|
000170  1d81              ADDS     r1,r0,#6
000172  4809              LDR      r0,|L1.408|
000174  2208              MOVS     r2,#8
000176  3010              ADDS     r0,r0,#0x10
000178  f7fffffe          BL       __aeabi_memcpy
00017c  e7da              B        |L1.308|
;;;292    
                          ENDP

                  is_conn_params_ok PROC
;;;30     
;;;31     static bool is_conn_params_ok(ble_gap_conn_params_t * p_conn_params)
00017e  8841              LDRH     r1,[r0,#2]
;;;32     {
;;;33         // Check if interval is within the acceptable range.
;;;34         // NOTE: Using max_conn_interval in the received event data because this contains
;;;35         //       the client's connection interval.
;;;36         if (
000180  4805              LDR      r0,|L1.408|
000182  3008              ADDS     r0,r0,#8
000184  8802              LDRH     r2,[r0,#0]  ; m_preferred_conn_params
000186  4291              CMP      r1,r2
000188  d304              BCC      |L1.404|
;;;37             (p_conn_params->max_conn_interval >= m_preferred_conn_params.min_conn_interval)
;;;38             && 
;;;39             (p_conn_params->max_conn_interval <= m_preferred_conn_params.max_conn_interval)
00018a  8840              LDRH     r0,[r0,#2]  ; m_preferred_conn_params
00018c  4281              CMP      r1,r0
00018e  d801              BHI      |L1.404|
;;;40         )
;;;41         {
;;;42             return true;
000190  2001              MOVS     r0,#1
;;;43         }
;;;44         else
;;;45         {
;;;46             return false;
;;;47         }
;;;48     }
000192  4770              BX       lr
                  |L1.404|
000194  2000              MOVS     r0,#0                 ;46
000196  4770              BX       lr
;;;49     
                          ENDP

                  |L1.408|
                          DCD      ||.data||
                  |L1.412|
                          DCD      0x0000ffff
                  |L1.416|
                          DCD      ||.bss||
                  |L1.420|
                          DCD      update_timeout_handler

                          AREA ||area_number.2||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.2||, ||.text||
                  ble_conn_params_stop PROC
;;;50     
;;;51     static void update_timeout_handler(void * p_context)
000000  b510              PUSH     {r4,lr}
;;;52     {
;;;53         UNUSED_PARAMETER(p_context);
;;;54     
;;;55         if (m_conn_handle != BLE_CONN_HANDLE_INVALID)
000002  4802              LDR      r0,|L2.12|
000004  6840              LDR      r0,[r0,#4]  ; m_conn_params_timer_id
000006  f7fffffe          BL       app_timer_stop
00000a  bd10              POP      {r4,pc}               ;52
;;;56         {
;;;57             // Check if we have reached the maximum number of attempts
;;;58             m_update_count++;
;;;59             if (m_update_count <= m_conn_params_config.max_conn_params_update_count)
;;;60             {
;;;61                 uint32_t err_code;
;;;62                 
;;;63                 // Parameters are not ok, send connection parameters update request.
;;;64                 err_code = sd_ble_gap_conn_param_update(m_conn_handle, &m_preferred_conn_params);
;;;65                 if ((err_code != NRF_SUCCESS) && (m_conn_params_config.error_handler != NULL))
;;;66                 {
;;;67                     m_conn_params_config.error_handler(err_code);
;;;68                 }
;;;69             }
;;;70             else
;;;71             {
;;;72                 m_update_count = 0;
;;;73                 
;;;74                 // Negotiation failed, disconnect automatically if this has been configured
;;;75                 if (m_conn_params_config.disconnect_on_fail)
;;;76                 {
;;;77                     uint32_t err_code;
;;;78                     
;;;79                     err_code = sd_ble_gap_disconnect(m_conn_handle, BLE_HCI_CONN_INTERVAL_UNACCEPTABLE);
;;;80                     if ((err_code != NRF_SUCCESS) && (m_conn_params_config.error_handler != NULL))
;;;81                     {
;;;82                         m_conn_params_config.error_handler(err_code);
;;;83                     }
;;;84                 }
;;;85                 
;;;86                 // Notify the application that the procedure has failed
;;;87                 if (m_conn_params_config.evt_handler != NULL)
;;;88                 {
;;;89                     ble_conn_params_evt_t evt;
;;;90                     
;;;91                     evt.evt_type = BLE_CONN_PARAMS_EVT_FAILED;
;;;92                     m_conn_params_config.evt_handler(&evt);
;;;93                 }
;;;94             }
;;;95         }
;;;96     }
;;;97     
                          ENDP

                  |L2.12|
                          DCD      ||.data||

                          AREA ||area_number.3||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.3||, ||.text||
                  ble_conn_params_change_conn_params PROC
;;;50     
;;;51     static void update_timeout_handler(void * p_context)
000000  b5f8              PUSH     {r3-r7,lr}
;;;52     {
;;;53         UNUSED_PARAMETER(p_context);
;;;54     
;;;55         if (m_conn_handle != BLE_CONN_HANDLE_INVALID)
000002  4601              MOV      r1,r0
000004  2208              MOVS     r2,#8
000006  4810              LDR      r0,|L3.72|
000008  f7fffffe          BL       __aeabi_memcpy
;;;56         {
;;;57             // Check if we have reached the maximum number of attempts
;;;58             m_update_count++;
00000c  480e              LDR      r0,|L3.72|
;;;59             if (m_update_count <= m_conn_params_config.max_conn_params_update_count)
00000e  df7a              SVC      #0x7a
000010  0004              MOVS     r4,r0                 ;58
000012  d10d              BNE      |L3.48|
000014  480c              LDR      r0,|L3.72|
000016  3008              ADDS     r0,r0,#8
000018  f7fffffe          BL       is_conn_params_ok
;;;60             {
;;;61                 uint32_t err_code;
;;;62                 
;;;63                 // Parameters are not ok, send connection parameters update request.
;;;64                 err_code = sd_ble_gap_conn_param_update(m_conn_handle, &m_preferred_conn_params);
00001c  2501              MOVS     r5,#1
00001e  2800              CMP      r0,#0
;;;65                 if ((err_code != NRF_SUCCESS) && (m_conn_params_config.error_handler != NULL))
000020  d008              BEQ      |L3.52|
000022  480a              LDR      r0,|L3.76|
000024  6941              LDR      r1,[r0,#0x14]  ; m_conn_params_config
000026  2900              CMP      r1,#0
000028  d002              BEQ      |L3.48|
;;;66                 {
;;;67                     m_conn_params_config.error_handler(err_code);
00002a  4668              MOV      r0,sp
;;;68                 }
;;;69             }
;;;70             else
;;;71             {
;;;72                 m_update_count = 0;
;;;73                 
;;;74                 // Negotiation failed, disconnect automatically if this has been configured
;;;75                 if (m_conn_params_config.disconnect_on_fail)
;;;76                 {
;;;77                     uint32_t err_code;
;;;78                     
;;;79                     err_code = sd_ble_gap_disconnect(m_conn_handle, BLE_HCI_CONN_INTERVAL_UNACCEPTABLE);
;;;80                     if ((err_code != NRF_SUCCESS) && (m_conn_params_config.error_handler != NULL))
;;;81                     {
;;;82                         m_conn_params_config.error_handler(err_code);
;;;83                     }
;;;84                 }
;;;85                 
;;;86                 // Notify the application that the procedure has failed
;;;87                 if (m_conn_params_config.evt_handler != NULL)
;;;88                 {
;;;89                     ble_conn_params_evt_t evt;
;;;90                     
;;;91                     evt.evt_type = BLE_CONN_PARAMS_EVT_FAILED;
;;;92                     m_conn_params_config.evt_handler(&evt);
;;;93                 }
;;;94             }
;;;95         }
;;;96     }
00002c  7005              STRB     r5,[r0,#0]
00002e  4788              BLX      r1                    ;72
                  |L3.48|
000030  4620              MOV      r0,r4                 ;72
000032  bdf8              POP      {r3-r7,pc}            ;75
                  |L3.52|
000034  4e04              LDR      r6,|L3.72|
000036  4904              LDR      r1,|L3.72|
000038  3e08              SUBS     r6,r6,#8              ;79
00003a  7035              STRB     r5,[r6,#0]            ;79
00003c  8870              LDRH     r0,[r6,#2]            ;80  ; m_conn_handle
00003e  df75              SVC      #0x75                 ;80
000040  4604              MOV      r4,r0                 ;80
000042  7075              STRB     r5,[r6,#1]            ;80
000044  e7f4              B        |L3.48|
;;;97     
                          ENDP

000046  0000              DCW      0x0000
                  |L3.72|
                          DCD      ||.data||+0x8
                  |L3.76|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  m_conn_params_config
                          %        28

                          AREA ||.data||, DATA, ALIGN=2

                  m_change_param
000000  00                DCB      0x00
                  m_update_count
000001  00                DCB      0x00
                  m_conn_handle
000002  0000              DCB      0x00,0x00
                  m_conn_params_timer_id
                          DCD      0x00000000
                  m_preferred_conn_params
                          %        8
                  m_current_conn_params
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\Source\\ble\\ble_conn_params.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_ble_conn_params_c_2dcac06e____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_ble_conn_params_c_2dcac06e____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_ble_conn_params_c_2dcac06e____REVSH|
#line 144
|__asm___17_ble_conn_params_c_2dcac06e____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
